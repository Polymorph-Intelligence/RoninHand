<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RoninHand Control Center</title>
    <script src="https://unpkg.com/@webcomponents/webcomponentsjs@2.4.3/webcomponentsjs-bundle.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1640029074/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248258/drawing_utils.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        .main-container {
            display: grid;
            grid-template-columns: 350px 1fr;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            gap: 1px;
            background: #2a2a2a;
        }

        /* Responsive design */
        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 350px 1fr;
            }
        }

        @media (max-width: 900px) {
            .main-container {
                grid-template-columns: 300px 1fr;
            }
        }

        @media (max-width: 700px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: 60px 1fr;
            }
            .left-panel {
                display: none;
            }
        }

        .urdf-container {
            background: #1a1a1a;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        urdf-viewer {
            width: 100%;
            height: 100%;
            display: block;
            flex: 1;
            min-height: 400px;
        }



        .header {
            grid-column: 1 / -1;
            background: #333;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #444;
            min-height: 60px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 300;
            margin: 0;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .device-connect {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .device-connect select, .device-connect button {
            padding: 8px 12px;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 14px;
            white-space: nowrap;
        }

        .device-connect button {
            background: #007acc;
            cursor: pointer;
            transition: background 0.2s;
        }

        .device-connect button:hover {
            background: #005a9e;
        }

        .device-connect button.connected {
            background: #28a745;
        }

        .reset-view-btn {
            padding: 10px;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            text-align: center;
            white-space: nowrap;
            min-width: 100px;
        }

        .reset-view-btn:hover {
            background: #555;
        }

        .left-panel {
            background: #2a2a2a;
            padding: 20px;
            overflow-x: hidden;
            border-right: 1px solid #444;
            min-width: 0;
            display: flex;
            flex-direction: column;
            padding-bottom: 40px;
            height: 100vh;
            overflow-y: auto;
        }

        .right-panel {
            background: #2a2a2a;
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid #444;
        }

        .urdf-container {
            background: #1a1a1a;
            position: relative;
        }

        urdf-viewer {
            width: 100%;
            height: 100%;
            display: block;
        }

        .panel-section {
            margin-bottom: 25px;
            padding: 15px;
            background: #333;
            border-radius: 8px;
            border: 1px solid #444;
            min-width: 0;
            overflow-wrap: break-word;
            flex-shrink: 0;
        }

        .panel-section:last-child {
            flex: 1;
            margin-bottom: 0;
        }

        #sequence-section {
            display: flex;
            flex-direction: column;
            margin-bottom: 20px;
        }

        #sequence-section.editing {
            flex: 1;
            min-height: 830px;
        }

        #sequence-section.editing .sequence-editor {
            flex: 1;
            min-height: 700px;
        }

        .panel-section h3 {
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: 500;
            color: #ddd;
        }



        .mode-toggle {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .mode-toggle button {
            padding: 10px;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            text-align: center;
        }

        .mode-toggle button:hover {
            background: #555;
        }

        .mode-toggle button.active {
            background: #007acc;
            border-color: #007acc;
        }

        .gesture-select {
            margin-bottom: 15px;
        }

        .gesture-select select {
            width: 100%;
            padding: 8px 12px;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 14px;
        }

        .gesture-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .gesture-buttons button {
            padding: 10px;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            text-align: center;
            width: 100%;
            word-wrap: break-word;
            white-space: normal;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            max-width: 100%;
            margin: 0;
        }

        /* Ensure static HTML buttons also have proper styling */
        #gesture-buttons .gesture-btn {
            padding: 10px;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            text-align: center;
            width: 100%;
            word-wrap: break-word;
            white-space: normal;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            max-width: 100%;
            margin: 0;
        }

        #gesture-buttons .gesture-btn:hover {
            background: #555;
        }

        .gesture-buttons button:hover {
            background: #555;
        }

        .gesture-buttons .default-btn {
            background: #6c757d;
            font-weight: bold;
            grid-column: 1 / -1; /* Span both columns */
        }

        /* Ensure buttons don't overflow */
        .gesture-buttons {
            max-width: 100%;
            box-sizing: border-box;
        }

        /* Responsive design for gesture buttons */
        @media (max-width: 1200px) {
            .gesture-buttons {
                grid-template-columns: 1fr;
            }
        }

        .servo-controls {
            display: none;
        }

        .servo-control {
            margin-bottom: 15px;
        }

        .servo-control label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }

        .servo-control input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .servo-control .limits {
            font-size: 11px;
            color: #888;
            font-family: monospace;
        }

        .servo-control .value {
            font-size: 11px;
            color: #007acc;
            font-family: monospace;
        }

        .action-buttons {
            margin-top: 15px;
        }

        .action-buttons button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .action-buttons button:hover {
            background: #c82333;
        }

        .sequence-section, .animation-section, .settings-section {
            display: none;
        }

        .sequence-list, .animation-controls, .settings-controls {
            margin-bottom: 15px;
        }

        .sequence-list button, .animation-controls button, .settings-controls button {
            width: 100%;
            padding: 8px 12px;
            margin: 5px 0;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 14px;
        }

        .sequence-list button:hover, .animation-controls button:hover, .settings-controls button:hover {
            background: #555;
        }

        .sequence-list .stop-btn, .animation-controls .stop-btn {
            background: #6c757d;
        }

        .add-gesture {
            display: block;
        }

        .gesture-management-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .gesture-input-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .gesture-input-group input {
            flex: 1;
            padding: 8px 12px;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 14px;
        }

        .gesture-input-group button {
            padding: 10px;
            background: #007acc;
            color: #fff;
            border: 1px solid #007acc;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            white-space: nowrap;
        }

        .gesture-input-group button:hover {
            background: #005a9e;
        }

        .gesture-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .gesture-actions button {
            padding: 10px;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .gesture-actions button:hover {
            background: #555;
        }

        .gesture-import-export {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .gesture-import-export button {
            padding: 10px;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .gesture-import-export button:hover {
            background: #555;
        }

        /* General button styling to ensure consistency */
        .panel-section button {
            padding: 10px;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            text-align: center;
        }

        .panel-section button:hover {
            background: #555;
        }

        /* Override for special buttons */
        .gesture-input-group button {
            background: #007acc;
            border-color: #007acc;
        }

        .gesture-input-group button:hover {
            background: #005a9e;
        }

        .gesture-buttons .default-btn {
            background: #6c757d;
            font-weight: bold;
        }

        .servo-limit-control {
            margin-bottom: 10px;
        }

        .servo-limit-control label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }

        .servo-limit-control input[type="number"] {
            width: 100%;
            padding: 5px;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 12px;
        }

        .sequence-item {
            display: flex;
            gap: 5px;
            margin: 5px 0;
            align-items: center;
        }

        .sequence-item button {
            flex: 1;
            padding: 5px 8px;
            font-size: 11px;
        }

        .sequence-editor {
            display: none;
            border: 1px solid #555;
            padding: 12px;
            border-radius: 6px;
            background: #333;
            display: flex;
            flex-direction: column;
            min-height: 400px;
        }

        .sequence-editor h3 {
            margin-bottom: 12px;
            font-size: 14px;
            color: #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .sequence-editor h3 .sequence-name {
            font-weight: bold;
            color: #007acc;
        }

        .sequence-steps-container {
            flex: 1;
            overflow-y: auto;
            border: 1px solid #444;
            border-radius: 4px;
            background: #2a2a2a;
            padding: 8px;
            margin-bottom: 12px;
            min-height: 300px;
        }

        .sequence-step {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin: 6px 0;
            padding: 8px;
            background: #333;
            border-radius: 6px;
            border: 1px solid #444;
            transition: all 0.2s ease;
        }

        .sequence-step:hover {
            background: #3a3a3a;
            border-color: #555;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .sequence-step:hover {
            background: #3a3a3a;
            border-color: #555;
        }

        .sequence-step.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
        }

        .sequence-step.drag-over {
            border-color: #007acc;
            background: #2a4a6a;
        }

        .step-number {
            background: #007acc;
            color: white;
            font-size: 10px;
            padding: 3px 6px;
            border-radius: 10px;
            font-weight: bold;
            min-width: 18px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: move;
            transition: all 0.2s;
            align-self: flex-start;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .step-number:hover {
            background: #005a9e;
            transform: scale(1.05);
        }

        .sequence-step select {
            padding: 6px 8px;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 6px;
            font-size: 11px;
            width: 100%;
            transition: all 0.2s;
        }

        .sequence-step select:focus {
            outline: none;
            border-color: #007acc;
            box-shadow: 0 0 0 2px rgba(0, 122, 204, 0.2);
        }

        .sequence-step input {
            padding: 6px 8px;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 6px;
            font-size: 11px;
            width: 100%;
            text-align: center;
            transition: all 0.2s;
        }

        .sequence-step input:focus {
            outline: none;
            border-color: #007acc;
            box-shadow: 0 0 0 2px rgba(0, 122, 204, 0.2);
        }

        .sequence-step button {
            padding: 6px 8px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            width: 100%;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
        }

        .sequence-step button:hover {
            background: #c82333;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .sequence-step button:hover {
            background: #c82333;
            transform: scale(1.05);
        }

        .sequence-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .sequence-controls button {
            padding: 10px 12px;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            font-weight: 500;
        }

        .sequence-controls button:hover {
            background: #555;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .sequence-controls .stop-btn {
            background: #6c757d;
        }

        .sequence-controls .stop-btn:hover {
            background: #5a6268;
        }

        .sequence-editor-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 6px;
            flex-shrink: 0;
        }

        .sequence-editor-controls button {
            padding: 10px 12px;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            font-weight: 500;
        }

        .sequence-editor-controls button:hover {
            background: #555;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .sequence-editor-controls #add-step-btn {
            background: #28a745;
            border-color: #28a745;
        }

        .sequence-editor-controls #add-step-btn:hover {
            background: #218838;
        }

        .sequence-editor-controls #save-sequence-btn {
            background: #007acc;
            border-color: #007acc;
        }

        .sequence-editor-controls #save-sequence-btn:hover {
            background: #005a9e;
        }

        .sequence-editor-controls #delete-sequence-btn {
            background: #dc3545;
            border-color: #dc3545;
        }

        .sequence-editor-controls #delete-sequence-btn:hover {
            background: #c82333;
        }

        .sequence-editor-controls #cancel-edit-btn {
            background: #6c757d;
            border-color: #6c757d;
        }

        .sequence-editor-controls #cancel-edit-btn:hover {
            background: #5a6268;
        }

        .sequence-preview {
            margin-top: 12px;
            padding: 12px;
            background: #2a2a2a;
            border-radius: 6px;
            border: 1px solid #444;
            font-size: 11px;
            color: #ccc;
            flex-shrink: 0;
        }

        .sequence-preview h4 {
            margin-bottom: 8px;
            color: #ddd;
            font-size: 13px;
            font-weight: 500;
        }

        .sequence-preview .step-preview {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            border-bottom: 1px solid #444;
        }

        .sequence-preview .step-preview:last-child {
            border-bottom: none;
        }

        .step-preview .gesture-name {
            color: #007acc;
            font-weight: 600;
        }

        .step-preview .delay-time {
            color: #888;
            font-family: monospace;
            font-weight: 500;
        }

        .empty-sequence {
            text-align: center;
            padding: 24px;
            color: #888;
            font-style: italic;
            font-size: 13px;
            background: #2a2a2a;
            border-radius: 6px;
            border: 1px dashed #555;
        }

        .drag-handle {
            cursor: move;
            color: #666;
            font-size: 12px;
            padding: 2px;
            margin-right: 4px;
        }

        .drag-handle:hover {
            color: #007acc;
        }

        /* Additional compact styling for sequence editor */
        .sequence-editor .sequence-steps-container::-webkit-scrollbar {
            width: 6px;
        }

        .sequence-editor .sequence-steps-container::-webkit-scrollbar-track {
            background: #2a2a2a;
        }

        .sequence-editor .sequence-steps-container::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 3px;
        }

        .sequence-editor .sequence-steps-container::-webkit-scrollbar-thumb:hover {
            background: #666;
        }

        /* Tooltip styles */
        .sequence-step select:focus,
        .sequence-step input:focus {
            outline: 2px solid #007acc;
            outline-offset: 1px;
        }

        /* Animation for step addition/removal */
        .sequence-step {
            animation: slideIn 0.2s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Compact mode for smaller screens */
        @media (max-width: 1200px) {
            .sequence-step {
                gap: 4px;
                padding: 6px;
            }
            
            .sequence-step select,
            .sequence-step input {
                font-size: 10px;
                padding: 4px 6px;
            }
            
            .step-number {
                font-size: 9px;
                padding: 1px 4px;
            }
        }

        .animation-settings div {
            margin: 10px 0;
        }

        .animation-settings label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }

        .animation-settings input[type="number"], .animation-settings input[type="checkbox"] {
            margin-left: 10px;
        }

        /* URDF Viewer Customization */
        urdf-viewer {
            --urdf-manipulator-background: #1a1a1a;
            --urdf-manipulator-highlight-color: #007acc;
            border: 1px solid #444;
            border-radius: 4px;
            width: 100% !important;
            height: 100% !important;
            min-height: 500px !important;
        }

        /* Add focus styles for better UX */
        urdf-viewer:focus {
            outline: 2px solid #007acc;
            outline-offset: 2px;
        }

        /* Add loading indicator */
        .urdf-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #007acc;
            font-size: 16px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
        }



        .urdf-fallback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            max-width: 400px;
            z-index: 10;
        }

        .urdf-fallback h3 {
            color: #dc3545;
            margin-bottom: 15px;
        }

        .urdf-fallback ul {
            text-align: left;
            margin: 15px 0;
        }

        .urdf-fallback li {
            margin: 5px 0;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #2a2a2a;
        }

        ::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #666;
        }

        /* Hand Tracking Styles */
        .hand-tracking-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .tracking-status {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 15px;
            background: #333;
            border-radius: 8px;
            border: 1px solid #555;
        }

        .tracking-status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tracking-status-header label {
            font-weight: bold;
            color: #ddd;
            font-size: 14px;
        }

        .tracking-status-indicator {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tracking-status-indicator.active {
            background: #28a745;
            color: #fff;
        }

        .tracking-status-indicator.inactive {
            background: #dc3545;
            color: #fff;
        }

        .tracking-status-indicator.waiting {
            background: #ffc107;
            color: #000;
        }

        .tracking-details {
            font-size: 12px;
            color: #888;
            line-height: 1.4;
        }

        .tracking-controls {
            display: flex;
            gap: 10px;
        }

        .tracking-controls button {
            flex: 1;
            padding: 12px;
            background: #007acc;
            color: #fff;
            border: 1px solid #007acc;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: 500;
        }

        .tracking-controls button:hover {
            background: #005a9e;
            transform: translateY(-1px);
        }

        .tracking-controls button#stop-tracking-btn {
            background: #dc3545;
            border-color: #dc3545;
        }

        .tracking-controls button#stop-tracking-btn:hover {
            background: #c82333;
        }

        .tracking-settings h4,
        .calibration-section h4,
        .mapping-preview h4 {
            margin-bottom: 10px;
            color: #ddd;
            font-size: 14px;
            font-weight: 500;
        }

        .mapping-control {
            margin-bottom: 12px;
        }

        .mapping-control label {
            display: block;
            margin-bottom: 6px;
            font-size: 12px;
            color: #ccc;
            font-weight: 500;
        }

        .mapping-control input[type="range"] {
            width: 100%;
            margin-bottom: 6px;
            height: 6px;
            border-radius: 3px;
            background: #555;
            outline: none;
            -webkit-appearance: none;
        }

        .mapping-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007acc;
            cursor: pointer;
            border: 2px solid #fff;
        }

        .mapping-control input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007acc;
            cursor: pointer;
            border: 2px solid #fff;
        }

        .mapping-control span {
            font-size: 11px;
            color: #007acc;
            font-family: monospace;
            font-weight: bold;
        }

        .calibration-section {
            border-top: 1px solid #555;
            padding-top: 15px;
        }

        .calibration-section button {
            width: 100%;
            padding: 10px 12px;
            margin: 5px 0;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: 500;
        }

        .calibration-section button:hover {
            background: #555;
            transform: translateY(-1px);
        }

        .calibration-section button#calibrate-hand-btn {
            background: #28a745;
            border-color: #28a745;
        }

        .calibration-section button#calibrate-hand-btn:hover {
            background: #218838;
        }

        .calibration-status {
            margin-top: 12px;
            padding: 12px;
            background: #333;
            border-radius: 6px;
            border: 1px solid #555;
            text-align: center;
            min-height: 20px;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .calibration-status span {
            font-size: 12px;
            font-weight: 500;
            line-height: 1.4;
            display: block;
        }

        .calibration-status.calibrated span {
            color: #28a745;
        }

        .calibration-status.not-calibrated span {
            color: #dc3545;
        }

        .calibration-status.calibrating span {
            color: #ffc107;
        }

        .mapping-preview {
            border-top: 1px solid #555;
            padding-top: 15px;
        }

        #joint-mapping-preview {
            max-height: 300px;
            overflow-y: auto;
            background: #333;
            border-radius: 6px;
            padding: 12px;
            border: 1px solid #555;
        }

        .joint-mapping-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px 0;
            border-bottom: 1px solid #444;
            font-size: 11px;
        }

        .joint-mapping-item:last-child {
            border-bottom: none;
        }

        .joint-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .joint-name {
            color: #ddd;
            font-weight: 500;
            font-size: 12px;
        }

        .joint-value {
            color: #007acc;
            font-family: monospace;
            font-weight: bold;
            font-size: 11px;
        }

        .joint-slider-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .joint-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #555;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .joint-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .joint-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .joint-slider.pinky { background: linear-gradient(to right, #FFEAA7, #FFD93D); }
        .joint-slider.pinky::-webkit-slider-thumb { background: #FFD93D; }
        .joint-slider.pinky::-moz-range-thumb { background: #FFD93D; }

        .joint-slider.ring { background: linear-gradient(to right, #96CEB4, #6BCF7F); }
        .joint-slider.ring::-webkit-slider-thumb { background: #6BCF7F; }
        .joint-slider.ring::-moz-range-thumb { background: #6BCF7F; }

        .joint-slider.middle { background: linear-gradient(to right, #45B7D1, #2E86AB); }
        .joint-slider.middle::-webkit-slider-thumb { background: #2E86AB; }
        .joint-slider.middle::-moz-range-thumb { background: #2E86AB; }

        .joint-slider.index { background: linear-gradient(to right, #4ECDC4, #26D0CE); }
        .joint-slider.index::-webkit-slider-thumb { background: #26D0CE; }
        .joint-slider.index::-moz-range-thumb { background: #26D0CE; }

        .joint-slider.thumb { background: linear-gradient(to right, #FF6B6B, #FF5252); }
        .joint-slider.thumb::-webkit-slider-thumb { background: #FF5252; }
        .joint-slider.thumb::-moz-range-thumb { background: #FF5252; }

        .joint-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .joint-controls button {
            padding: 4px 8px;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.2s;
        }

        .joint-controls button:hover {
            background: #555;
        }

        .joint-controls button.active {
            background: #007acc;
            border-color: #007acc;
        }

        .tracking-active {
            color: #28a745 !important;
        }

        .tracking-inactive {
            color: #dc3545 !important;
        }

        .tracking-waiting {
            color: #ffc107 !important;
        }

        /* Camera Feed Styles */
        .camera-feed {
            border-top: 1px solid #555;
            padding-top: 15px;
            margin-bottom: 15px;
        }

        .camera-feed h4 {
            margin-bottom: 12px;
            color: #ddd;
            font-size: 14px;
            font-weight: 500;
        }

        .camera-container {
            position: relative;
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }

        #camera-canvas {
            background: #000;
            display: block;
            border: 2px solid #555;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            max-width: 100%;
            height: auto;
        }

        .camera-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }

        /* Camera Selection Styles */
        .camera-selection {
            border-top: 1px solid #555;
            padding-top: 15px;
            margin-bottom: 15px;
        }

        .camera-selection h4 {
            margin-bottom: 12px;
            color: #ddd;
            font-size: 14px;
            font-weight: 500;
        }

        .camera-selection select {
            width: 100%;
            padding: 10px 12px;
            background: #444;
            color: #fff;
            border: 1px solid #555;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 10px;
            font-weight: 500;
        }

        .camera-selection button {
            width: 100%;
            padding: 10px 12px;
            background: #007acc;
            color: #fff;
            border: 1px solid #007acc;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: 500;
        }

        .camera-selection button:hover {
            background: #005a9e;
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="header">
            <div style="display: flex; align-items: center; gap: 15px;">
                <img src="media/PolymorphLogo.png" alt="Polymorph Logo" style="height: 40px; width: auto;">
                <h1 style="font-size: 28px; font-weight: bold; color: #fff; margin: 0; letter-spacing: 1px;">RoninHand Control Center</h1>
            </div>
            <div class="header-controls">
            <div class="device-connect">
                <select id="device-select">
                    <option value="">Select a device</option>
                </select>
                <button id="connect-btn">Connect</button>
                </div>
                <button id="reset-view-btn" style="padding: 10px; background: #444; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; transition: all 0.2s; font-size: 14px; text-align: center; white-space: nowrap; min-width: 100px;">Reset View</button>
            </div>
        </div>

        <div class="left-panel">
            <div class="panel-section">
                <h3>Control Modes</h3>
                <div class="mode-toggle">
                    <button id="edit-mode" class="active">Gesture Mode</button>
                    <button id="sequence-mode">Sequence Mode</button>
                    <button id="hand-tracking-mode">Hand Tracking Mode</button>
                    <button id="animation-mode">Test Joint Limits</button>
                    <button id="settings-mode">Settings</button>
                </div>
            </div>



            <div class="panel-section" id="gesture-buttons" style="display: block;">
                <h3>Toggle Gesture</h3>
                <div class="gesture-buttons">
                    <button class="default-btn" id="default-btn" style="padding: 10px; background: #6c757d; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; transition: all 0.2s; font-size: 12px; text-align: center; width: 100%; word-wrap: break-word; white-space: normal; min-height: 44px; display: flex; align-items: center; justify-content: center; box-sizing: border-box; max-width: 100%; margin: 0; font-weight: bold; grid-column: 1 / -1;">Default Position</button>
                    <!-- Gesture buttons will be populated dynamically in alphabetical order -->
                </div>
            </div>

            <div class="panel-section" id="add-gesture" style="display: block;">
                <h3>Gesture Management</h3>
                <div class="add-gesture">
                    <div class="gesture-select" style="margin-bottom: 15px;">
                        <select id="gesture" style="width: 100%; padding: 8px; margin-bottom: 10px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px;">
                            <option value="">Default Position</option>
                            <!-- Gesture options will be populated dynamically in alphabetical order -->
                        </select>
                        <p style="font-size: 12px; color: #aaa; margin: 0;">Select a gesture above to manage it (rename, remove, etc.)</p>
                    </div>
                    <div class="gesture-management-controls">
                        <div class="gesture-input-group">
                    <input type="text" id="new-gesture-name" placeholder="New Gesture Name">
                        </div>
                        <div class="gesture-input-group">
                    <button id="add-gesture-btn">Add Gesture</button>
                </div>
                        <div class="gesture-actions">
                            <button id="remove-gesture-btn">Remove Selected</button>
                            <button id="rename-gesture-btn">Rename Selected</button>
                            <button id="duplicate-gesture-btn">Duplicate Selected</button>
            </div>
                        <div class="gesture-import-export">
                            <button id="export-gestures-btn">Export Gestures</button>
                            <button id="import-gestures-btn">Import Gestures</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel-section" id="servo-controls" class="servo-controls">
                <h3>Servo Controls</h3>
                <div class="servo-control" style="margin-bottom: 20px;">
                    <label>
                        <input type="checkbox" id="thumb-clearance-checkbox"> Enable Thumb Clearance
                    </label>
                </div>
                <div class="servo-control">
                    <label>Pinky PIP & DIP (Servo 1):</label>
                    <input type="range" id="servo_1">
                    <span class="limits" id="servo_1_limits"></span>
                    <span class="value" id="servo_1_value"></span>
                </div>
                <div class="servo-control">
                    <label>Pinky MCP (Servo 7):</label>
                    <input type="range" id="servo_7">
                    <span class="limits" id="servo_7_limits"></span>
                    <span class="value" id="servo_7_value"></span>
                </div>
                <div class="servo-control">
                    <label>Ring PIP & DIP (Servo 2):</label>
                    <input type="range" id="servo_2">
                    <span class="limits" id="servo_2_limits"></span>
                    <span class="value" id="servo_2_value"></span>
                </div>
                <div class="servo-control">
                    <label>Ring MCP (Servo 3):</label>
                    <input type="range" id="servo_3">
                    <span class="limits" id="servo_3_limits"></span>
                    <span class="value" id="servo_3_value"></span>
                </div>
                <div class="servo-control">
                    <label>Middle MCP (Servo 4):</label>
                    <input type="range" id="servo_4">
                    <span class="limits" id="servo_4_limits"></span>
                    <span class="value" id="servo_4_value"></span>
                </div>
                <div class="servo-control">
                    <label>Middle PIP & DIP (Servo 5):</label>
                    <input type="range" id="servo_5">
                    <span class="limits" id="servo_5_limits"></span>
                    <span class="value" id="servo_5_value"></span>
                </div>
                <div class="servo-control">
                    <label>Index PIP & DIP (Servo 6):</label>
                    <input type="range" id="servo_6">
                    <span class="limits" id="servo_6_limits"></span>
                    <span class="value" id="servo_6_value"></span>
                </div>
                <div class="servo-control">
                    <label>Index MCP (Servo 8):</label>
                    <input type="range" id="servo_8">
                    <span class="limits" id="servo_8_limits"></span>
                    <span class="value" id="servo_8_value"></span>
                </div>
                <div class="servo-control">
                    <label>Thumb MCP (Servo 9):</label>
                    <input type="range" id="servo_9">
                    <span class="limits" id="servo_9_limits"></span>
                    <span class="value" id="servo_9_value"></span>
                </div>
                <div class="servo-control">
                    <label>Thumb PIP & DIP (Servo 10):</label>
                    <input type="range" id="servo_10">
                    <span class="limits" id="servo_10_limits"></span>
                    <span class="value" id="servo_10_value"></span>
                </div>
                <div class="servo-control">
                    <label>Thumb MCP Roll (Servo 12):</label>
                    <input type="range" id="servo_12">
                    <span class="limits" id="servo_12_limits"></span>
                    <span class="value" id="servo_12_value"></span>
                </div>
                <div class="action-buttons">
                    <button id="save-btn" style="display: none;">Save Positions</button>
                </div>
            </div>

            <div class="panel-section" id="sequence-section" style="display: none;">
                <h3>Sequences</h3>
                <div class="sequence-list" id="sequence-list">
                    <!-- Sequence items added dynamically -->
                </div>
                <div class="sequence-controls">
                    <button class="stop-btn" id="stop-sequence-btn">Stop Sequence</button>
                    <button id="add-sequence-btn">Add Sequence</button>
                </div>
                <div class="sequence-editor" id="sequence-editor" style="display: none;">
                    <h3>
                        <span>Editing</span>
                        <span class="sequence-name" id="current-sequence-name"></span>
                    </h3>
                    <div class="sequence-steps-container" id="sequence-steps">
                        <div class="empty-sequence">No steps added yet. Click "Add Step" to begin.</div>
                    </div>
                    <div class="sequence-editor-controls">
                        <button id="add-step-btn">Add Step</button>
                        <button id="save-sequence-btn">Save</button>
                        <button id="delete-sequence-btn">Delete</button>
                        <button id="cancel-edit-btn">Cancel</button>
                    </div>
                    <div class="sequence-preview" id="sequence-preview" style="display: none;">
                        <h4>Sequence Preview</h4>
                        <div id="preview-content"></div>
                    </div>
                </div>
            </div>

            <div class="panel-section" id="animation-section" style="display: none;">
                <div class="animation-controls">
                    <button id="start-animation-btn">Start Test</button>
                    <button class="stop-btn" id="stop-animation-btn">Stop Test</button>
                    <label>
                        <input type="checkbox" id="loop-animation"> Loop
                    </label>
                </div>
            </div>

            <div class="panel-section" id="settings-section" style="display: none;">
                <h3>Settings</h3>
                <div class="settings-controls">
                    <h3>Servo Limits</h3>
                    <div id="servo-limits-controls">
                        <!-- Servo limit controls added dynamically -->
                    </div>
                    <h3>Other Settings</h3>
                    <div class="servo-limit-control">
                        <label>Animation Stagger Delay (ms):</label>
                        <input type="number" id="animation-stagger-delay" min="0" step="1">
                    </div>
                    <div class="servo-limit-control">
                        <label>Default Sequence Step Delay (ms):</label>
                        <input type="number" id="default-sequence-step-delay" min="0" step="100">
                    </div>
                    <div class="servo-limit-control">
                        <label>Default Position Offset (from min):</label>
                        <input type="number" id="default-position-offset" min="0" max="200" step="1" value="60">
                        <small style="color: #888; display: block; margin-top: 2px;">Offset added to min value for default position (except thumb MCP roll)</small>
                    </div>
                    <button id="save-settings-btn">Save Settings</button>
                </div>
            </div>

            <div class="panel-section" id="hand-tracking-section" style="display: none;">
                <h3>Hand Tracking Controls</h3>
                <div class="hand-tracking-controls">
                    <div class="tracking-controls">
                        <button id="start-tracking-btn">Start Hand Tracking</button>
                        <button id="stop-tracking-btn" style="display: none;">Stop Hand Tracking</button>
                    </div>
                    <div class="camera-selection">
                        <h4>Camera Selection</h4>
                        <select id="camera-select">
                            <option value="">Select a camera</option>
                        </select>
                        <button id="refresh-cameras-btn">Refresh Cameras</button>
                    </div>
                    <div class="camera-feed">
                        <h4>Camera Feed</h4>
                        <div class="camera-container">
                            <canvas id="camera-canvas" width="320" height="240"></canvas>
                            <div class="camera-overlay" id="camera-overlay">No Signal</div>
                        </div>
                    </div>
                    <div class="tracking-settings">
                        <h4>Mapping Settings</h4>
                        <div class="mapping-control">
                            <label>Smoothing Factor:</label>
                            <input type="range" id="smoothing-factor" min="0" max="1" step="0.1" value="0.3">
                            <span id="smoothing-value">0.3</span>
                        </div>
                        <div class="mapping-control">
                            <label>Response Speed:</label>
                            <input type="range" id="response-speed" min="0.1" max="2.0" step="0.1" value="1.0">
                            <span id="response-value">1.0</span>
                        </div>
                        <div class="mapping-control">
                            <label>Dead Zone:</label>
                            <input type="range" id="dead-zone" min="0" max="0.3" step="0.01" value="0.05">
                            <span id="dead-zone-value">0.05</span>
                        </div>
                    </div>
                    <div class="calibration-section">
                        <h4>Hand Calibration</h4>
                        <button id="calibrate-hand-btn">Calibrate Hand Range</button>
                        <button id="reset-calibration-btn">Reset Calibration</button>
                        <div class="calibration-status">
                            <span id="calibration-status">Not calibrated</span>
                    </div>
                    <div class="mapping-preview">
                        <h4>Joint Mapping Preview</h4>
                        <div id="joint-mapping-preview">
                            <!-- Joint mapping preview will be populated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="urdf-container">
            <div id="urdf-viewer" style="width: 100%; height: 100%; min-height: 500px;"></div>
            <div class="urdf-loading" id="urdf-loading" style="display: none;">Loading Ronin Hand Model...</div>
            <div class="urdf-fallback" id="urdf-fallback" style="display: none;">
                <h3>URDF Model Not Available</h3>
                <p>The 3D model could not be loaded. Please check:</p>
                <ul>
                    <li>Server is running on port 8000</li>
                                    <li>URDF file exists at descriptions/RoninHand.urdf</li>
                <li>Mesh files are in descriptions/meshes/</li>
                </ul>
                <p>Check browser console for detailed error messages.</p>
            </div>

        </div>


    </div>

    <script>
        // Joint mapping configuration
        const jointMapping = {
            'servo_1': 'pinky_pip', // Pinky PIP
            'servo_2': 'ring_pip', // Ring PIP
            'servo_3': 'ring_mcp', // Ring MCP
            'servo_4': 'middle_mcp', // Middle MCP
            'servo_5': 'middle_pip', // Middle PIP
            'servo_6': 'index_pip', // Index PIP
            'servo_7': 'pinky_mcp', // Pinky MCP
            'servo_8': 'index_mcp', // Index MCP
            'servo_9': 'thumb_mcp', // Thumb MCP
            'servo_10': 'thumb_pip', // Thumb PIP & DIP (combined)
            'servo_12': 'thumb_abduction' // Thumb Abduction
        };

        // DIP joint mapping - DIP joints that move with their corresponding PIP joints
        const dipJointMapping = {
            'pinky_pip': 'pinky_dip',   // Pinky DIP moves with Pinky PIP
            'ring_pip': 'ring_dip',     // Ring DIP moves with Ring PIP
            'middle_pip': 'middle_dip', // Middle DIP moves with Middle PIP
            'index_pip': 'index_dip',   // Index DIP moves with Index PIP
            'thumb_pip': 'thumb_dip'    // Thumb DIP moves with Thumb PIP
        };

        // Reverse mapping for URDF to servo
        const reverseJointMapping = {};
        for (const [servo, joint] of Object.entries(jointMapping)) {
            reverseJointMapping[joint] = servo;
        }

        let servoLimits = {};
        let settings = {
            animation_stagger_delay: 60,
            default_sequence_step_delay: 2000,
            default_position_offset: 60,
            device_name: ''
        };
        let isConnected = false;
        let currentMode = 'edit';
        let sequenceInterval = null;
        let animationTimeout = null;
        let isAnimating = false;
        let editingSequence = null;
        let thumbClearanceEnabled = false;
        let urdfLoader = null;
        
        // Hand Tracking Variables
        let hands = null;
        let camera = null;
        let isTrackingActive = false;
        let handTrackingSettings = {
            smoothingFactor: 0.3,
            responseSpeed: 1.0,
            deadZone: 0.05
        };
        let handCalibration = {
            minValues: {},
            maxValues: {},
            isCalibrated: false
        };
        let smoothedJointValues = {};
        let lastHandLandmarks = null;
        
        // Calibration data structure
        let calibrationData = {};
        const calibrationJoints = [
            { servoId: 'servo_1', jointName: 'pinky_pip', description: 'Pinky PIP' },
            { servoId: 'servo_2', jointName: 'ring_pip', description: 'Ring PIP' },
            { servoId: 'servo_3', jointName: 'ring_mcp', description: 'Ring MCP' },
            { servoId: 'servo_4', jointName: 'middle_mcp', description: 'Middle MCP' },
            { servoId: 'servo_5', jointName: 'middle_pip', description: 'Middle PIP' },
            { servoId: 'servo_6', jointName: 'index_pip', description: 'Index PIP' },
            { servoId: 'servo_7', jointName: 'pinky_mcp', description: 'Pinky MCP' },
            { servoId: 'servo_8', jointName: 'index_mcp', description: 'Index MCP' },
            { servoId: 'servo_9', jointName: 'thumb_mcp', description: 'Thumb MCP' },
            { servoId: 'servo_10', jointName: 'thumb_pip', description: 'Thumb PIP' },
            { servoId: 'servo_10', jointName: 'thumb_dip', description: 'Thumb DIP' },
            { servoId: 'servo_12', jointName: 'thumb_abduction', description: 'Thumb Abduction' }
        ];

        // Initialize URDF loader
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('DOM loaded, initializing URDF loader...');
            
            try {
                urdfLoader = new URDFLoader();
                await urdfLoader.init('urdf-viewer');
                console.log('URDF loader initialized successfully');
                
                // Load calibration data
                loadCalibrationData();
                
                // Set up URDF controls
                setupURDFControls();
                
                // Reset URDF model to default positions
                resetURDFToDefault();
                
                // Update all servo positions to match URDF
                updateAllServosFromURDF();
            } catch (error) {
                console.error('Failed to initialize URDF loader:', error);
                document.getElementById('urdf-loading').style.display = 'none';
                document.getElementById('urdf-fallback').style.display = 'block';
            }
        });

        // Update servo controls from URDF joint changes
        function updateServoFromURDF(servoId, angle) {
            const slider = document.getElementById(servoId);
            if (slider) {
                // Convert joint angle to servo position using calibration
                const servoPosition = urdfLoader.convertJointAngleToServoPosition(servoId, angle, jointMapping[servoId]);
                slider.value = servoPosition;
                document.getElementById(`${servoId}_value`).textContent = servoPosition;
            }
        }

        // Update URDF from servo changes
        function updateURDFFromServo(servoId, position) {
            const jointName = jointMapping[servoId];
            if (jointName && urdfLoader && urdfLoader.robot) {
                // Convert servo position to joint angle using calibration
                const jointAngle = urdfLoader.convertServoPositionWithCalibration(servoId, position, jointName);
                urdfLoader.setJointValue(jointName, jointAngle);
                
                // Move corresponding DIP joint if it exists
                const dipJointName = dipJointMapping[jointName];
                if (dipJointName) {
                    // Move DIP joint by the same amount as PIP joint
                    urdfLoader.setJointValue(dipJointName, jointAngle);
                }
            }
        }

        // Animate URDF model with smooth transitions
        function animateURDFServo(servoId, targetPosition, duration = 200) {
            return new Promise((resolve) => {
                const jointName = jointMapping[servoId];
                if (jointName && urdfLoader && urdfLoader.robot) {
                    const targetAngle = urdfLoader.convertServoPositionWithCalibration(servoId, targetPosition, jointName);
                    const currentAngle = urdfLoader.getJointValue(jointName) || 0;
                    
                    // Get corresponding DIP joint
                    const dipJointName = dipJointMapping[jointName];
                    const currentDipAngle = dipJointName ? urdfLoader.getJointValue(dipJointName) || 0 : 0;
                    
                    // Create smooth animation
                    const startTime = performance.now();
                    const animate = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const easedProgress = easeInOutCubic(progress);
                        
                        const currentAngleValue = currentAngle + (targetAngle - currentAngle) * easedProgress;
                        urdfLoader.setJointValue(jointName, currentAngleValue);
                        
                        // Move corresponding DIP joint by the same amount
                        if (dipJointName) {
                            urdfLoader.setJointValue(dipJointName, currentAngleValue);
                        }
                        
                        // Logging for index and thumb joints
                        if (['servo_6', 'servo_8', 'servo_9', 'servo_10', 'servo_12'].includes(servoId)) {
                            console.log(`URDF ${servoId}: ${jointName} = ${currentAngleValue.toFixed(3)} rad, ${dipJointName ? dipJointName + ' = ' + currentAngleValue.toFixed(3) + ' rad' : ''}`);
                        }
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            resolve();
                        }
                    };
                    
                    requestAnimationFrame(animate);
                } else {
                    resolve();
                }
            });
        }

        // Easing function for smooth animation
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // Force reset all DIP joints to match their corresponding PIP joints
        function resetDIPJoints() {
            if (!urdfLoader || !urdfLoader.robot) return;
            
            console.log('Resetting DIP joints to match PIP joints');
            for (const [pipJoint, dipJoint] of Object.entries(dipJointMapping)) {
                const pipAngle = urdfLoader.getJointValue(pipJoint) || 0;
                urdfLoader.setJointValue(dipJoint, pipAngle);
                console.log(`Reset ${dipJoint} to match ${pipJoint}: ${pipAngle}`);
            }
        }

        // Animate URDF model with multiple servo positions
        function animateURDFModel(positions, duration = 300) {
            if (!urdfLoader || !urdfLoader.robot) {
                console.log('URDF loader or robot not available for animation');
                return;
            }
            
            console.log('Animating URDF model with positions:', positions);
            const targetValues = {};
            for (const servoId in positions) {
                const jointName = jointMapping[servoId];
                if (jointName) {
                    const jointAngle = urdfLoader.convertServoPositionWithCalibration(servoId, positions[servoId], jointName);
                    targetValues[jointName] = jointAngle;
                    console.log(`Converting ${servoId} (${positions[servoId]}) -> ${jointName} (${jointAngle})`);
                    
                    // Add corresponding DIP joint if it exists
                    const dipJointName = dipJointMapping[jointName];
                    if (dipJointName) {
                        targetValues[dipJointName] = jointAngle;
                        console.log(`Adding DIP joint ${dipJointName} with same angle ${jointAngle}`);
                    }
                }
            }
            
            console.log('Target joint values:', targetValues);
            // Animate the transition
            urdfLoader.animateJoints(targetValues, duration);
        }

        // Update all servos from URDF joint positions
        function updateAllServosFromURDF() {
            if (!urdfLoader || !urdfLoader.robot) return;
            
            for (const [servoId, jointName] of Object.entries(jointMapping)) {
                const joint = urdfLoader.joints.get(jointName);
                if (joint) {
                    const angle = joint.angle;
                    const servoPosition = urdfLoader.convertJointAngleToServoPosition(servoId, angle, jointName);
                    
                    // Update slider and value display
                    const slider = document.getElementById(servoId);
                    const valueSpan = document.getElementById(`${servoId}_value`);
                    if (slider && valueSpan) {
                        slider.value = servoPosition;
                        valueSpan.textContent = servoPosition;
                    }
                }
            }
        }

        // Set up URDF viewer controls
        function setupURDFControls() {
            const resetViewBtn = document.getElementById('reset-view-btn');

            // Reset view
            if (resetViewBtn) {
                resetViewBtn.addEventListener('click', () => {
                    console.log('Reset view clicked');
                    if (urdfLoader) {
                        urdfLoader.centerAndPositionModel();
                    }
                });
                
                // Add hover effects
                resetViewBtn.addEventListener('mouseenter', () => {
                    resetViewBtn.style.background = '#555';
                });
                
                resetViewBtn.addEventListener('mouseleave', () => {
                    resetViewBtn.style.background = '#444';
                });
            }
        }

        // Load calibration data from localStorage
        function loadCalibrationData() {
            try {
                const savedCalibration = localStorage.getItem('urdfCalibration');
                if (savedCalibration) {
                    calibrationData = JSON.parse(savedCalibration);
                    console.log('Loaded calibration data:', calibrationData);
                    
                    // Set calibration data in URDF loader
                    if (urdfLoader) {
                        urdfLoader.setCalibrationData(calibrationData);
                    }
                } else {
                    // Load default calibration data
                    loadDefaultCalibrationData();
                }
            } catch (error) {
                console.error('Failed to load calibration data:', error);
                loadDefaultCalibrationData();
            }
        }

        // Load default calibration data
        function loadDefaultCalibrationData() {
            calibrationData = {};
            for (const jointMapping of calibrationJoints) {
                calibrationData[jointMapping.jointName] = {
                    openPosition: 20,
                    closedPosition: 500,
                    closedJointAngle: 1.57,
                    multiplier: 1.0,
                    offset: 0.0
                };
            }
            
            if (urdfLoader) {
                urdfLoader.setCalibrationData(calibrationData);
            }
        }

        // Save calibration data to localStorage
        function saveCalibrationData() {
            try {
                localStorage.setItem('urdfCalibration', JSON.stringify(calibrationData));
                console.log('Calibration data saved:', calibrationData);
            } catch (error) {
                console.error('Failed to save calibration data:', error);
            }
        }

        // Reset URDF model to default positions
        function resetURDFToDefault() {
            if (!urdfLoader || !urdfLoader.robot || !servoLimits) return;
            
            const defaultPositions = {};
            for (const servoId in servoLimits) {
                defaultPositions[servoId] = getDefaultPosition(servoId);
            }
            console.log('Resetting URDF model to default positions:', defaultPositions);
            animateURDFModel(defaultPositions, 500);
        }

        // Initialize the rest of the application
        function initializeApp() {
            // Fetch initial data
            Promise.all([fetchServoLimits(), fetchSettings()]).then(() => {
                updateGestureDropdown();
                updateGestureButtons();
                updateSequenceList();
                resetToDefault();
                updateStatus();
                
                // Set initial UI state for edit mode
                servoControls.style.display = 'block';
                saveBtn.style.display = 'inline-block';
                addGestureSection.style.display = 'block';
                gestureButtons.style.display = 'block';
                sequenceSection.style.display = 'none';
                animationSection.style.display = 'none';
                handTrackingSection.style.display = 'none';
                settingsSection.style.display = 'none';
                
                // Reset URDF model to default positions if ready
                if (urdfLoader && urdfLoader.robot) {
                    resetURDFToDefault();
                }
                
                // Sync URDF with current servo positions after a delay
                setTimeout(() => {
                    if (urdfLoader && urdfLoader.robot) {
                        updateAllServosFromURDF();
                    }
                }, 1000);
                
                // Start periodic URDF sync
                startURDFSync();
                
                // Pause polling when user interacts with web interface
                document.addEventListener('click', pauseURDFSync);
                document.addEventListener('keydown', pauseURDFSync);
                
                // Pause polling when user interacts with gesture controls
                const gestureButtons = document.querySelectorAll('.gesture-btn, #default-btn');
                gestureButtons.forEach(btn => {
                    btn.addEventListener('click', pauseURDFSync);
                });
                
                // Pause polling when user moves sliders
                const servoSliders = document.querySelectorAll('input[type="range"]');
                servoSliders.forEach(slider => {
                    slider.addEventListener('input', pauseURDFSync);
                });
            });
        }
        
        // Function to animate URDF to new positions smoothly
        function animateURDFToPositions(newPositions, duration = 300) {
            if (!urdfLoader || !urdfLoader.robot) return;
            
            const startTime = performance.now();
            const startPositions = {};
            
            // Get current URDF positions
            for (const [servoId, jointName] of Object.entries(jointMapping)) {
                const joint = urdfLoader.joints.get(jointName);
                if (joint) {
                    startPositions[servoId] = urdfLoader.convertJointAngleToServoPosition(servoId, joint.angle, jointName);
                }
            }
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easedProgress = easeInOutCubic(progress);
                
                // Interpolate each servo position
                for (const [servoId, newPosition] of Object.entries(newPositions)) {
                    const startPosition = startPositions[servoId] || 0;
                    const currentPosition = startPosition + (newPosition - startPosition) * easedProgress;
                    
                    updateURDFFromServo(servoId, Math.round(currentPosition));
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        // Track last known positions to avoid unnecessary updates
        let lastKnownPositions = {};
        let userInteracting = false;
        
        // Function to sync URDF with current positions from server
        function syncURDFWithCurrentPositions() {
            if (!urdfLoader || !urdfLoader.robot) return;
            
            fetch('http://localhost:8000/current_positions')
                .then(response => response.json())
                .then(data => {
                    // Check if positions actually changed
                    let positionsChanged = false;
                    for (const [servoId, position] of Object.entries(data)) {
                        if (lastKnownPositions[servoId] !== position) {
                            positionsChanged = true;
                            break;
                        }
                    }
                    
                    if (positionsChanged) {
                        // Update last known positions
                        lastKnownPositions = { ...data };
                        // Animate to new positions
                        animateURDFToPositions(data, 300);
                    }
                })
                .catch(err => {
                    // Silently ignore errors to avoid console spam
                });
        }
        
        // Start periodic URDF sync (fallback to polling for now)
        let urdfSyncInterval = null;
        
        function startURDFSync() {
            // Sync every 200ms for more responsive updates
            urdfSyncInterval = setInterval(syncURDFWithCurrentPositions, 200);
        }
        
        function stopURDFSync() {
            if (urdfSyncInterval) {
                clearInterval(urdfSyncInterval);
                urdfSyncInterval = null;
            }
        }
        
        // Stop polling when user interacts with web interface
        function pauseURDFSync() {
            // Only pause if we're not already paused
            if (!userInteracting) {
                userInteracting = true;
                stopURDFSync();
                // Resume after 1 second of no interaction
                setTimeout(() => {
                    userInteracting = false;
                    startURDFSync();
                }, 1000);
            }
        }

        // Update status display
        function updateStatus() {
            // Status display
            console.log('Status: Connected =', isConnected, 'Mode =', currentMode);
        }

        // Debounce function to limit request rate
        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        // Calculate default position for a servo
        function getDefaultPosition(servoId) {
            if (!servoLimits[servoId]) return 0;
            
            // For thumb MCP roll (servo_12), use min value
            if (servoId === 'servo_12') {
                return servoLimits[servoId].min;
            }
            
            // For all other servos, use min + offset
            const offset = settings.default_position_offset || 60;
            return Math.min(servoLimits[servoId].min + offset, servoLimits[servoId].max);
        }

        // Reset to default positions
        async function resetToDefault() {
            console.log('Resetting to default positions');
            try {
                await fetchWithTimeout('http://localhost:8000/default', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                }, 5000);
                // Update sliders to reflect default positions
                const servoSliders = document.querySelectorAll('input[type="range"]');
                servoSliders.forEach(slider => {
                    const servoId = slider.id;
                    if (servoLimits[servoId]) {
                        const defaultPosition = getDefaultPosition(servoId);
                        slider.value = defaultPosition;
                        document.getElementById(`${servoId}_value`).textContent = defaultPosition;
                        // Update URDF model
                        updateURDFFromServo(servoId, defaultPosition);
                    }
                });
                
                // Animate URDF model to default positions
                const defaultPositions = {};
                for (const servoId in servoLimits) {
                    defaultPositions[servoId] = getDefaultPosition(servoId);
                }
                console.log('Default positions for URDF animation:', defaultPositions);
                animateURDFModel(defaultPositions, 500);
            } catch (err) {
                console.error('Error resetting to default positions:', err);
            }
        }

        // Toggle modes with default position reset
        const editModeBtn = document.getElementById('edit-mode');
        const sequenceModeBtn = document.getElementById('sequence-mode');
        const animationModeBtn = document.getElementById('animation-mode');
        const settingsModeBtn = document.getElementById('settings-mode');
        const servoControls = document.getElementById('servo-controls');
        const saveBtn = document.getElementById('save-btn');
        const gestureSelect = document.getElementById('gesture');
        const gestureButtons = document.getElementById('gesture-buttons');
        const sequenceSection = document.getElementById('sequence-section');
        const animationSection = document.getElementById('animation-section');
        const settingsSection = document.getElementById('settings-section');
        const sequenceList = document.getElementById('sequence-list');
        const sequenceEditor = document.getElementById('sequence-editor');
        const currentSequenceName = document.getElementById('current-sequence-name');
        const sequenceSteps = document.getElementById('sequence-steps');
        const addStepBtn = document.getElementById('add-step-btn');
        const saveSequenceBtn = document.getElementById('save-sequence-btn');
        const cancelEditBtn = document.getElementById('cancel-edit-btn');
        const defaultBtn = document.getElementById('default-btn');
        const addGestureSection = document.getElementById('add-gesture');
        const addGestureBtn = document.getElementById('add-gesture-btn');
        const removeGestureBtn = document.getElementById('remove-gesture-btn');
        const renameGestureBtn = document.getElementById('rename-gesture-btn');
        const duplicateGestureBtn = document.getElementById('duplicate-gesture-btn');
        const exportGesturesBtn = document.getElementById('export-gestures-btn');
        const importGesturesBtn = document.getElementById('import-gestures-btn');
        const newGestureNameInput = document.getElementById('new-gesture-name');
        const stopSequenceBtn = document.getElementById('stop-sequence-btn');
        const addSequenceBtn = document.getElementById('add-sequence-btn');
        const startAnimationBtn = document.getElementById('start-animation-btn');
        const stopAnimationBtn = document.getElementById('stop-animation-btn');
        const loopAnimationCheckbox = document.getElementById('loop-animation');
        const servoLimitsControls = document.getElementById('servo-limits-controls');
        const saveSettingsBtn = document.getElementById('save-settings-btn');
        const animationStaggerDelayInput = document.getElementById('animation-stagger-delay');
        const defaultSequenceStepDelayInput = document.getElementById('default-sequence-step-delay');
        const defaultPositionOffsetInput = document.getElementById('default-position-offset');
        const deviceSelect = document.getElementById('device-select');
        const connectBtn = document.getElementById('connect-btn');
        const thumbClearanceCheckbox = document.getElementById('thumb-clearance-checkbox');

        // Hand Tracking Elements
        const handTrackingModeBtn = document.getElementById('hand-tracking-mode');
        const handTrackingSection = document.getElementById('hand-tracking-section');
        const startTrackingBtn = document.getElementById('start-tracking-btn');
        const stopTrackingBtn = document.getElementById('stop-tracking-btn');
        const trackingStatus = document.getElementById('tracking-status');
        const smoothingFactor = document.getElementById('smoothing-factor');
        const smoothingValue = document.getElementById('smoothing-value');
        const responseSpeed = document.getElementById('response-speed');
        const responseValue = document.getElementById('response-value');
        const deadZone = document.getElementById('dead-zone');
        const deadZoneValue = document.getElementById('dead-zone-value');
        const calibrateHandBtn = document.getElementById('calibrate-hand-btn');
        const resetCalibrationBtn = document.getElementById('reset-calibration-btn');
        const calibrationStatus = document.getElementById('calibration-status');
        const jointMappingPreview = document.getElementById('joint-mapping-preview');

        // Camera Selection Elements
        const cameraSelect = document.getElementById('camera-select');
        const refreshCamerasBtn = document.getElementById('refresh-cameras-btn');

        editModeBtn.addEventListener('click', async () => {
            console.log('Switching to Gesture Mode');
            currentMode = 'edit';
            editModeBtn.classList.add('active');
            sequenceModeBtn.classList.remove('active');
            animationModeBtn.classList.remove('active');
            handTrackingModeBtn.classList.remove('active');
            settingsModeBtn.classList.remove('active');
            servoControls.style.display = 'block';
            saveBtn.style.display = 'inline-block';
            addGestureSection.style.display = 'block';
            gestureButtons.style.display = 'block';
            sequenceSection.style.display = 'none';
            animationSection.style.display = 'none';
            handTrackingSection.style.display = 'none';
            settingsSection.style.display = 'none';
            stopSequence();
            stopAnimation();
            
            // Stop hand tracking if active
            if (isTrackingActive) {
                stopHandTracking();
            }
            
            // Always reset URDF model to default positions
            const defaultPositions = {};
            for (const servoId in servoLimits) {
                defaultPositions[servoId] = getDefaultPosition(servoId);
            }
            animateURDFModel(defaultPositions, 500);
            
            // Ensure DIP joints are synchronized after mode switch
            setTimeout(() => {
                resetDIPJoints();
            }, 600);
            
            if (isConnected) await resetToDefault();
        });



        sequenceModeBtn.addEventListener('click', async () => {
            console.log('Switching to Sequence Mode');
            currentMode = 'sequence';
            sequenceModeBtn.classList.add('active');
            editModeBtn.classList.remove('active');
            animationModeBtn.classList.remove('active');
            handTrackingModeBtn.classList.remove('active');
            settingsModeBtn.classList.remove('active');
            servoControls.style.display = 'none';
            saveBtn.style.display = 'none';
            addGestureSection.style.display = 'none';
            gestureButtons.style.display = 'none';
            sequenceSection.style.display = 'block';
            animationSection.style.display = 'none';
            handTrackingSection.style.display = 'none';
            settingsSection.style.display = 'none';
            stopSequence();
            stopAnimation();
            
            // Stop hand tracking if active
            if (isTrackingActive) {
                stopHandTracking();
            }
            
            // Always reset URDF model to default positions
            const defaultPositions = {};
            for (const servoId in servoLimits) {
                defaultPositions[servoId] = getDefaultPosition(servoId);
            }
            animateURDFModel(defaultPositions, 500);
            
            if (isConnected) await resetToDefault();
            updateSequenceList();
        });

        animationModeBtn.addEventListener('click', async () => {
            console.log('Switching to Test Joint Limits');
            currentMode = 'animation';
            animationModeBtn.classList.add('active');
            editModeBtn.classList.remove('active');
            sequenceModeBtn.classList.remove('active');
            handTrackingModeBtn.classList.remove('active');
            settingsModeBtn.classList.remove('active');
            servoControls.style.display = 'none';
            saveBtn.style.display = 'none';
            addGestureSection.style.display = 'none';
            gestureButtons.style.display = 'none';
            sequenceSection.style.display = 'none';
            animationSection.style.display = 'block';
            handTrackingSection.style.display = 'none';
            settingsSection.style.display = 'none';
            stopSequence();
            stopAnimation();
            
            // Stop hand tracking if active
            if (isTrackingActive) {
                stopHandTracking();
            }
            
            // Always reset URDF model to default positions
            const defaultPositions = {};
            for (const servoId in servoLimits) {
                defaultPositions[servoId] = getDefaultPosition(servoId);
            }
            animateURDFModel(defaultPositions, 500);
            
            if (isConnected) await resetToDefault();
        });

        settingsModeBtn.addEventListener('click', async () => {
            console.log('Switching to Settings');
            currentMode = 'settings';
            settingsModeBtn.classList.add('active');
            editModeBtn.classList.remove('active');
            sequenceModeBtn.classList.remove('active');
            animationModeBtn.classList.remove('active');
            handTrackingModeBtn.classList.remove('active');
            servoControls.style.display = 'none';
            saveBtn.style.display = 'none';
            addGestureSection.style.display = 'none';
            gestureButtons.style.display = 'none';
            sequenceSection.style.display = 'none';
            animationSection.style.display = 'none';
            handTrackingSection.style.display = 'none';
            settingsSection.style.display = 'block';
            stopSequence();
            stopAnimation();
            
            // Stop hand tracking if active
            if (isTrackingActive) {
                stopHandTracking();
            }
            
            // Always reset URDF model to default positions
            const defaultPositions = {};
            for (const servoId in servoLimits) {
                defaultPositions[servoId] = getDefaultPosition(servoId);
            }
            animateURDFModel(defaultPositions, 500);
            
            if (isConnected) await resetToDefault();
            initializeSettings();
        });

        handTrackingModeBtn.addEventListener('click', async () => {
            console.log('Switching to Hand Tracking Mode');
            currentMode = 'hand-tracking';
            handTrackingModeBtn.classList.add('active');
            editModeBtn.classList.remove('active');
            sequenceModeBtn.classList.remove('active');
            animationModeBtn.classList.remove('active');
            settingsModeBtn.classList.remove('active');
            servoControls.style.display = 'none';
            saveBtn.style.display = 'none';
            addGestureSection.style.display = 'none';
            gestureButtons.style.display = 'none';
            sequenceSection.style.display = 'none';
            animationSection.style.display = 'none';
            settingsSection.style.display = 'none';
            handTrackingSection.style.display = 'block';
            stopSequence();
            stopAnimation();
            
            // Stop hand tracking if active
            if (isTrackingActive) {
                stopHandTracking();
            }
            
            // Ensure URDF model is properly loaded and reset
            try {
                if (urdfLoader && urdfLoader.robot) {
                    // Always reset URDF model to default positions
                    const defaultPositions = {};
                    for (const servoId in servoLimits) {
                        defaultPositions[servoId] = getDefaultPosition(servoId);
                    }
                    animateURDFModel(defaultPositions, 500);
                    
                    // Force a render update to ensure joints are visible
                    setTimeout(() => {
                        if (urdfLoader.render) {
                            urdfLoader.render();
                        }
                    }, 600);
                }
            } catch (error) {
                console.error('Error resetting URDF model:', error);
            }
            
            if (isConnected) await resetToDefault();
            initializeHandTracking();
        });

        // Update servo values in real-time (Edit Mode) with debouncing
        const servoSliders = document.querySelectorAll('input[type="range"]');
        let pendingPositions = {};
        const sendUpdate = debounce(async () => {
            if (Object.keys(pendingPositions).length === 0) return;
            const positions = { ...pendingPositions };
                pendingPositions = {};
            
            // Update UI values immediately for responsive feedback
            for (const servoId in positions) {
                document.getElementById(`${servoId}_value`).textContent = positions[servoId];
            }
            
            if (!isConnected) {
                console.log('Not connected to device, updating URDF only');
                // Update URDF model immediately when not connected
                animateURDFToPositions(positions, 100);
                return;
            }
            
            try {
                await fetchWithTimeout('http://localhost:8000/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ positions })
                }, 5000);
                
                // Update URDF model immediately after successful update
                animateURDFToPositions(positions, 100);
            } catch (err) {
                console.error('Error sending update:', err);
            }
        }, 100);

        servoSliders.forEach(slider => {
            slider.addEventListener('input', () => {
                const servoId = slider.id;
                const value = parseInt(slider.value);
                document.getElementById(`${servoId}_value`).textContent = value;

                // Update URDF model in real-time for immediate visual feedback
                updateURDFFromServo(servoId, value);

                if (currentMode === 'edit') {
                    pendingPositions[servoId] = value;
                    sendUpdate();
                }
            });
        });

        // Fetch with timeout
        async function fetchWithTimeout(url, options, timeout = 5000) {
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeout);
            try {
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal
                });
                clearTimeout(id);
                return response;
            } catch (err) {
                clearTimeout(id);
                throw err;
            }
        }

        // Load gesture positions and update servos when selecting a gesture (Edit Mode)
        document.getElementById('gesture').addEventListener('change', loadGesturePositions);

        async function loadGesturePositions() {
            console.log('Loading gesture positions');
            const gesture = document.getElementById('gesture').value;
            
                            // Handle default position
                if (!gesture) {
                    console.log('Loading default position');
                    const defaultPositions = {};
                    for (const servoId in servoLimits) {
                        defaultPositions[servoId] = getDefaultPosition(servoId);
                    }
                
                if (currentMode === 'edit') {
                    animateURDFModel(defaultPositions, 500);
                    
                    // Update sliders to default positions
                    setTimeout(() => {
                        for (const servoId in defaultPositions) {
                            const slider = document.getElementById(servoId);
                            const valueSpan = document.getElementById(`${servoId}_value`);
                            if (slider && valueSpan) {
                                slider.value = defaultPositions[servoId];
                                valueSpan.textContent = defaultPositions[servoId];
                            }
                        }
                    }, 100);
                }

                if (isConnected) {
                    await fetchWithTimeout('http://localhost:8000/default', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({})
                    }, 5000);
                }
                return;
            }
            
            try {
                const response = await fetchWithTimeout('http://localhost:8000/gestures', {}, 5000);
                const data = await response.json();
                const positions = data.gestures[gesture];

                if (currentMode === 'edit') {
                    // Animate the transition to new gesture positions
                    animateURDFModel(positions, 500);
                    
                    // Update sliders after animation starts
                    setTimeout(() => {
                        for (const servoId in positions) {
                            const slider = document.getElementById(servoId);
                            const valueSpan = document.getElementById(`${servoId}_value`);
                            if (slider && valueSpan) {
                                slider.value = positions[servoId];
                                valueSpan.textContent = positions[servoId];
                            }
                        }
                    }, 100);
                }

                if (isConnected) {
                    await fetchWithTimeout('http://localhost:8000/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ gesture, thumb_clearance: thumbClearanceEnabled })
                    }, 5000);
                }
            } catch (err) {
                console.error('Error loading gesture positions:', err);
            }
        }

        // Save positions (Edit Mode)
        saveBtn.addEventListener('click', async () => {
            console.log('Saving positions');
            const gesture = document.getElementById('gesture').value;
            const positions = {};
            
            // Only collect servo positions from servo sliders
            const servoSliders = document.querySelectorAll('input[type="range"]');
            servoSliders.forEach(slider => {
                // Only include actual servo sliders (servo_1, servo_2, etc.)
                if (slider.id.startsWith('servo_')) {
                    positions[slider.id] = parseInt(slider.value);
                }
            });

            try {
                await fetchWithTimeout('http://localhost:8000/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ gesture, positions })
                }, 5000);
                alert('Positions saved!');
            } catch (err) {
                console.error('Error saving positions:', err);
            }
        });

        // Gesture buttons in Test Mode
        function updateGestureButtons() {
            console.log('Updating gesture buttons');
            const gestureBtnContainer = document.getElementById('gesture-buttons');
            if (!gestureBtnContainer) {
                console.warn('Gesture buttons container not found');
                return;
            }
            
            // Find the actual buttons container (the div with class 'gesture-buttons')
            const buttonsContainer = gestureBtnContainer.querySelector('.gesture-buttons');
            if (!buttonsContainer) {
                console.warn('Buttons container not found');
                return;
            }
            
            // Clear all existing gesture buttons but keep the default button
            const existingButtons = buttonsContainer.querySelectorAll('.gesture-btn');
            existingButtons.forEach(btn => btn.remove());
            
            // Ensure the buttons container has grid layout
            buttonsContainer.style.display = 'grid';
            buttonsContainer.style.gridTemplateColumns = '1fr 1fr';
            buttonsContainer.style.gap = '8px';
            
            // Ensure the default button spans both columns
            const defaultBtn = document.getElementById('default-btn');
            if (defaultBtn) {
                defaultBtn.style.gridColumn = '1 / -1';
            }

            fetch('http://localhost:8000/gestures')
                .then(response => response.json())
                .then(data => {
                    const gestures = Object.keys(data.gestures).sort(); // Sort alphabetically
                    console.log('Creating buttons for gestures:', gestures);
                    gestures.forEach(gesture => {
                        const btn = document.createElement('button');
                        btn.className = 'gesture-btn';
                        btn.setAttribute('data-gesture', gesture);
                        btn.textContent = gesture.charAt(0).toUpperCase() + gesture.slice(1).replace('_', ' ');
                        
                        btn.style.padding = '10px';
                        btn.style.background = '#444';
                        btn.style.color = '#fff';
                        btn.style.border = '1px solid #555';
                        btn.style.borderRadius = '4px';
                        btn.style.cursor = 'pointer';
                        btn.style.transition = 'all 0.2s';
                        btn.style.fontSize = '12px';
                        btn.style.textAlign = 'center';
                        btn.style.width = '100%';
                        btn.style.wordWrap = 'break-word';
                        btn.style.whiteSpace = 'normal';
                        btn.style.minHeight = '44px';
                        btn.style.display = 'flex';
                        btn.style.alignItems = 'center';
                        btn.style.justifyContent = 'center';
                        btn.style.boxSizing = 'border-box';
                        btn.style.maxWidth = '100%';
                        btn.style.margin = '0';
                        
                        btn.addEventListener('click', async () => {
                            console.log(`Executing gesture: ${gesture}`);
                            stopSequence();
                            stopAnimation();
                            
                            // Force pause polling to let web UI work
                            pauseURDFSync();
                            
                            // Update URDF model with gesture positions (animated)
                            try {
                                const response = await fetchWithTimeout('http://localhost:8000/gestures', {}, 5000);
                                const data = await response.json();
                                const positions = data.gestures[gesture];
                                
                                // Animate the transition to new gesture positions
                                animateURDFModel(positions, 500);
                            } catch (err) {
                                console.error('Error updating URDF with gesture:', err);
                            }
                            
                            if (isConnected) {
                                try {
                                    await fetchWithTimeout('http://localhost:8000/execute', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ gesture, thumb_clearance: thumbClearanceEnabled })
                                    }, 5000);
                                } catch (err) {
                                    console.error(`Error executing gesture ${gesture}:`, err);
                                }
                            } else {
                                console.log('Not connected to device, gesture execution skipped');
                            }
                        });
                        
                        buttonsContainer.appendChild(btn);
                        
                        // Ensure the button works with grid layout
                        btn.style.gridColumn = 'auto';
                        btn.style.gridRow = 'auto';
                        btn.style.gridArea = 'auto';
                    });
                })
                .catch(err => console.error('Error updating gesture buttons:', err));
        }

        // Default position button in Test Mode
        defaultBtn.addEventListener('click', async () => {
            console.log('Resetting to default position');
            stopSequence();
            stopAnimation();
            
            // Animate URDF model to default positions
            const defaultPositions = {};
            for (const servoId in servoLimits) {
                defaultPositions[servoId] = getDefaultPosition(servoId);
            }
            animateURDFModel(defaultPositions, 500);
            
            if (isConnected) {
                try {
                    await fetchWithTimeout('http://localhost:8000/default', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({})
                    }, 5000);
                } catch (err) {
                    console.error('Error resetting to default position:', err);
                }
            }
        });

        // Sequence Mode Functions
        function updateSequenceList() {
            console.log('Updating sequence list');
            fetch('http://localhost:8000/gestures')
                .then(response => response.json())
                .then(data => {
                    const sequences = Object.keys(data.sequences || {});
                    const sequenceListContainer = document.getElementById('sequence-list');
                    // Clear all dynamically added items
                    sequenceListContainer.innerHTML = '';

                    sequences.forEach(sequenceId => {
                        // Create a container for each sequence
                        const sequenceItem = document.createElement('div');
                        sequenceItem.className = 'sequence-item';

                        // Add sequence button
                        const btn = document.createElement('button');
                        btn.className = 'sequence-btn';
                        btn.setAttribute('data-sequence', sequenceId);
                        btn.textContent = sequenceId.replace('sequence_', 'Sequence ').replace('_', ' ');
                        btn.addEventListener('click', () => startSequence(sequenceId));
                        sequenceItem.appendChild(btn);

                        // Add edit button
                        const editBtn = document.createElement('button');
                        editBtn.className = 'edit-sequence-btn';
                        editBtn.textContent = 'Edit';
                        editBtn.addEventListener('click', () => editSequence(sequenceId));
                        sequenceItem.appendChild(editBtn);

                        sequenceListContainer.appendChild(sequenceItem);
                    });
                })
                .catch(err => console.error('Error updating sequence list:', err));
        }

        function startSequence(sequenceId) {
            console.log(`Starting sequence: ${sequenceId}`);
            stopSequence();
            stopAnimation();
            
            fetch('http://localhost:8000/gestures')
                .then(response => response.json())
                .then(data => {
                    const sequence = data.sequences[sequenceId];
                    let index = 0;

                    function playNext() {
                        if (index >= sequence.length) {
                            index = 0; // Loop back to start
                        }
                        const step = sequence[index];
                        
                        // Always update URDF model with gesture positions
                        try {
                            const positions = data.gestures[step.gesture];
                            animateURDFModel(positions, 300);
                        } catch (err) {
                            console.error('Error updating URDF with sequence gesture:', err);
                        }
                        
                        // Only execute on device if connected
                        if (isConnected) {
                        fetchWithTimeout('http://localhost:8000/execute', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ gesture: step.gesture })
                        }, 5000).then(() => {
                            index++;
                            if (sequenceInterval) {
                                setTimeout(playNext, step.delay);
                            }
                        }).catch(err => {
                            console.error(`Error executing sequence step ${index} (${step.gesture}):`, err);
                                index++;
                                if (sequenceInterval) {
                                    setTimeout(playNext, step.delay);
                                }
                            });
                        } else {
                            // If not connected, just advance to next step
                            index++;
                            if (sequenceInterval) {
                                setTimeout(playNext, step.delay);
                            }
                        }
                    }

                    sequenceInterval = {};
                    playNext();
                })
                .catch(err => console.error(`Error starting sequence ${sequenceId}:`, err));
        }

        function stopSequence() {
            console.log('Stopping sequence');
            if (sequenceInterval) {
                sequenceInterval = null;
            }
        }

        stopSequenceBtn.addEventListener('click', stopSequence);

        let sequenceCounter = 2; // Start after initial sequences (sequence_1, sequence_2)
        addSequenceBtn.addEventListener('click', () => {
            console.log('Adding new sequence');
            sequenceCounter++;
            const newSequenceId = `sequence_${sequenceCounter}`;
            const newSequence = [
                { gesture: 'peace', delay: settings.default_sequence_step_delay },
                { gesture: 'fist', delay: settings.default_sequence_step_delay }
            ];

            fetchWithTimeout('http://localhost:8000/add_sequence', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sequenceId: newSequenceId, sequence: newSequence })
            }, 5000).then(() => {
                updateSequenceList();
                editSequence(newSequenceId);
            }).catch(err => console.error('Error adding sequence:', err));
        });

        function editSequence(sequenceId) {
            console.log(`Editing sequence: ${sequenceId}`);
            stopSequence();
            editingSequence = sequenceId;
            currentSequenceName.textContent = sequenceId.replace('sequence_', 'Sequence ').replace('_', ' ');
            sequenceList.style.display = 'none';
            sequenceEditor.style.display = 'block';
            addSequenceBtn.style.display = 'none';
            stopSequenceBtn.style.display = 'none';
            
            // Add editing class to sequence section for proper height
            document.getElementById('sequence-section').classList.add('editing');

            fetch('http://localhost:8000/gestures')
                .then(response => response.json())
                .then(data => {
                    const sequence = data.sequences[sequenceId];
                    const gestures = Object.keys(data.gestures).sort(); // Alphabetically sorted
                    sequenceSteps.innerHTML = '';

                    if (sequence && sequence.length > 0) {
                        sequence.forEach((step, index) => {
                            createSequenceStep(step, index + 1, gestures);
                        });
                        updateSequencePreview();
                    } else {
                        sequenceSteps.innerHTML = '<div class="empty-sequence">No steps added yet. Click "Add Step" to begin.</div>';
                    }
                })
                .catch(err => console.error(`Error editing sequence ${sequenceId}:`, err));
        }

        function createSequenceStep(step, stepNumber, gestures) {
            const stepDiv = document.createElement('div');
            stepDiv.className = 'sequence-step';
            stepDiv.setAttribute('data-step-index', stepNumber - 1);
            
            stepDiv.innerHTML = `
                <div class="step-number" title="Drag to reorder">${stepNumber}</div>
                <select class="gesture-select">
                    ${gestures.map(g => `<option value="${g}" ${g === step.gesture ? 'selected' : ''}>${g.charAt(0).toUpperCase() + g.slice(1).replace('_', ' ')}</option>`).join('')}
                </select>
                <input type="number" class="delay-input" value="${step.delay}" min="0" step="100" placeholder="Delay (ms)" title="Delay in milliseconds">
                <button class="remove-step-btn" title="Remove this step">Remove Step</button>
            `;
            
            sequenceSteps.appendChild(stepDiv);

            // Add event listeners
            stepDiv.querySelector('.remove-step-btn').addEventListener('click', () => {
                stepDiv.remove();
                updateStepNumbers();
                updateSequencePreview();
            });

            stepDiv.querySelector('.gesture-select').addEventListener('change', () => {
                validateSequenceStep(stepDiv);
                updateSequencePreview();
            });
            stepDiv.querySelector('.delay-input').addEventListener('input', () => {
                validateSequenceStep(stepDiv);
                updateSequencePreview();
            });

            // Add drag and drop functionality
            setupDragAndDrop(stepDiv);
            
            // Add right-click context menu for additional options
            stepDiv.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showStepContextMenu(e, stepDiv);
            });
        }

        function updateStepNumbers() {
            const steps = sequenceSteps.querySelectorAll('.sequence-step');
            steps.forEach((step, index) => {
                step.querySelector('.step-number').textContent = index + 1;
                step.setAttribute('data-step-index', index);
            });
        }

        function updateSequencePreview() {
            const preview = document.getElementById('sequence-preview');
            const previewContent = document.getElementById('preview-content');
            const steps = sequenceSteps.querySelectorAll('.sequence-step');
            
            if (steps.length === 0) {
                preview.style.display = 'none';
                return;
            }

            preview.style.display = 'block';
            previewContent.innerHTML = '';

            steps.forEach((step, index) => {
                const gesture = step.querySelector('.gesture-select').value;
                const delay = step.querySelector('.delay-input').value;
                
                const stepPreview = document.createElement('div');
                stepPreview.className = 'step-preview';
                stepPreview.innerHTML = `
                    <span class="gesture-name">${gesture.charAt(0).toUpperCase() + gesture.slice(1).replace('_', ' ')}</span>
                    <span class="delay-time">${delay}ms</span>
                `;
                previewContent.appendChild(stepPreview);
            });
        }

        addStepBtn.addEventListener('click', () => {
            console.log('Adding step to sequence');
            fetch('http://localhost:8000/gestures')
                .then(response => response.json())
                .then(data => {
                    const gestures = Object.keys(data.gestures).sort(); // Alphabetically sorted
                    const newStep = {
                        gesture: gestures[0] || 'default',
                        delay: settings.default_sequence_step_delay
                    };
                    
                    // Remove empty sequence message if present
                    const emptyMessage = sequenceSteps.querySelector('.empty-sequence');
                    if (emptyMessage) {
                        emptyMessage.remove();
                    }
                    
                    const stepNumber = sequenceSteps.querySelectorAll('.sequence-step').length + 1;
                    createSequenceStep(newStep, stepNumber, gestures);
                    updateSequencePreview();
                })
                .catch(err => console.error('Error adding step to sequence:', err));
        });

        saveSequenceBtn.addEventListener('click', () => {
            console.log('Saving sequence');
            const steps = Array.from(sequenceSteps.querySelectorAll('.sequence-step')).map(step => ({
                gesture: step.querySelector('.gesture-select').value,
                delay: parseInt(step.querySelector('.delay-input').value) || 0
            }));

            if (steps.length === 0) {
                alert('Please add at least one step to the sequence.');
                return;
            }

            fetchWithTimeout('http://localhost:8000/update_sequence', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sequenceId: editingSequence, sequence: steps })
            }, 5000).then(() => {
                sequenceList.style.display = 'block';
                sequenceEditor.style.display = 'none';
                addSequenceBtn.style.display = 'inline-block';
                stopSequenceBtn.style.display = 'inline-block';
                document.getElementById('sequence-section').classList.remove('editing');
                updateSequenceList();
            }).catch(err => console.error('Error saving sequence:', err));
        });

        function setupDragAndDrop(stepElement) {
            stepElement.draggable = true;
            
            stepElement.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', stepElement.getAttribute('data-step-index'));
                stepElement.classList.add('dragging');
            });
            
            stepElement.addEventListener('dragend', () => {
                stepElement.classList.remove('dragging');
            });
            
            stepElement.addEventListener('dragover', (e) => {
                e.preventDefault();
                const draggingElement = sequenceSteps.querySelector('.dragging');
                if (draggingElement && draggingElement !== stepElement) {
                    stepElement.classList.add('drag-over');
                }
            });
            
            stepElement.addEventListener('dragleave', () => {
                stepElement.classList.remove('drag-over');
            });
            
            stepElement.addEventListener('drop', (e) => {
                e.preventDefault();
                stepElement.classList.remove('drag-over');
                
                const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
                const dropIndex = parseInt(stepElement.getAttribute('data-step-index'));
                
                if (draggedIndex !== dropIndex) {
                    reorderSteps(draggedIndex, dropIndex);
                }
            });
        }

        function reorderSteps(fromIndex, toIndex) {
            const steps = Array.from(sequenceSteps.querySelectorAll('.sequence-step'));
            const draggedStep = steps[fromIndex];
            
            if (draggedStep) {
                if (toIndex > fromIndex) {
                    sequenceSteps.insertBefore(draggedStep, steps[toIndex + 1]);
                } else {
                    sequenceSteps.insertBefore(draggedStep, steps[toIndex]);
                }
                
                updateStepNumbers();
                updateSequencePreview();
            }
        }

        cancelEditBtn.addEventListener('click', () => {
            console.log('Cancelling sequence edit');
            sequenceList.style.display = 'block';
            sequenceEditor.style.display = 'none';
            addSequenceBtn.style.display = 'inline-block';
            stopSequenceBtn.style.display = 'inline-block';
            document.getElementById('sequence-section').classList.remove('editing');
        });

        // Add delete sequence functionality
        document.getElementById('delete-sequence-btn').addEventListener('click', () => {
            if (!editingSequence) return;
            
            if (confirm(`Are you sure you want to delete "${editingSequence.replace('sequence_', 'Sequence ').replace('_', ' ')}"? This action cannot be undone.`)) {
                console.log('Deleting sequence:', editingSequence);
                
                fetchWithTimeout('http://localhost:8000/delete_sequence', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sequenceId: editingSequence })
                }, 5000).then(() => {
                    sequenceList.style.display = 'block';
                    sequenceEditor.style.display = 'none';
                    addSequenceBtn.style.display = 'inline-block';
                    stopSequenceBtn.style.display = 'inline-block';
                    document.getElementById('sequence-section').classList.remove('editing');
                    updateSequenceList();
                }).catch(err => console.error('Error deleting sequence:', err));
            }
        });

        // Add keyboard shortcuts for sequence editing
        document.addEventListener('keydown', (e) => {
            if (sequenceEditor.style.display === 'block') {
                if (e.ctrlKey || e.metaKey) {
                    switch (e.key) {
                        case 's':
                            e.preventDefault();
                            saveSequenceBtn.click();
                            break;
                        case 'Enter':
                            e.preventDefault();
                            addStepBtn.click();
                            break;
                        case 'Escape':
                            e.preventDefault();
                            cancelEditBtn.click();
                            break;
                    }
                }
            }
        });

        // Add validation and better UX for sequence steps
        function validateSequenceStep(stepElement) {
            const gestureSelect = stepElement.querySelector('.gesture-select');
            const delayInput = stepElement.querySelector('.delay-input');
            
            // Validate delay
            const delay = parseInt(delayInput.value);
            if (delay < 0) {
                delayInput.value = 0;
            } else if (delay > 10000) {
                delayInput.value = 10000;
            }
            
            // Validate gesture selection
            if (!gestureSelect.value) {
                gestureSelect.value = gestureSelect.options[0]?.value || 'default';
            }
        }

        // Add step duplication functionality
        function duplicateStep(stepElement) {
            const gesture = stepElement.querySelector('.gesture-select').value;
            const delay = stepElement.querySelector('.delay-input').value;
            
            fetch('http://localhost:8000/gestures')
                .then(response => response.json())
                .then(data => {
                    const gestures = Object.keys(data.gestures).sort();
                    const newStep = { gesture, delay: parseInt(delay) };
                    const stepNumber = sequenceSteps.querySelectorAll('.sequence-step').length + 1;
                    createSequenceStep(newStep, stepNumber, gestures);
                    updateSequencePreview();
                });
        }

        // Context menu for sequence steps
        function showStepContextMenu(e, stepElement) {
            // Remove existing context menu
            const existingMenu = document.querySelector('.step-context-menu');
            if (existingMenu) {
                existingMenu.remove();
            }

            const menu = document.createElement('div');
            menu.className = 'step-context-menu';
            menu.style.cssText = `
                position: fixed;
                top: ${e.clientY}px;
                left: ${e.clientX}px;
                background: #333;
                border: 1px solid #555;
                border-radius: 4px;
                padding: 4px 0;
                z-index: 1000;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            `;

            const menuItems = [
                { text: 'Duplicate Step', action: () => duplicateStep(stepElement) },
                { text: 'Move Up', action: () => moveStepUp(stepElement) },
                { text: 'Move Down', action: () => moveStepDown(stepElement) },
                { text: 'Remove Step', action: () => stepElement.querySelector('.remove-step-btn').click() }
            ];

            menuItems.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.style.cssText = `
                    padding: 8px 12px;
                    cursor: pointer;
                    font-size: 12px;
                    color: #fff;
                    transition: background 0.2s;
                `;
                menuItem.textContent = item.text;
                menuItem.addEventListener('mouseenter', () => {
                    menuItem.style.background = '#555';
                });
                menuItem.addEventListener('mouseleave', () => {
                    menuItem.style.background = 'transparent';
                });
                menuItem.addEventListener('click', () => {
                    item.action();
                    menu.remove();
                });
                menu.appendChild(menuItem);
            });

            document.body.appendChild(menu);

            // Close menu when clicking outside
            const closeMenu = (e) => {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            };
            setTimeout(() => document.addEventListener('click', closeMenu), 100);
        }

        function moveStepUp(stepElement) {
            const prevStep = stepElement.previousElementSibling;
            if (prevStep && prevStep.classList.contains('sequence-step')) {
                sequenceSteps.insertBefore(stepElement, prevStep);
                updateStepNumbers();
                updateSequencePreview();
            }
        }

        function moveStepDown(stepElement) {
            const nextStep = stepElement.nextElementSibling;
            if (nextStep && nextStep.classList.contains('sequence-step')) {
                sequenceSteps.insertBefore(nextStep, stepElement);
                updateStepNumbers();
                updateSequencePreview();
            }
        }

        // Animation Mode Functions
        async function updateServo(servoId, targetValue) {
            console.log(`Updating servo ${servoId} to ${targetValue} (limits: ${servoLimits[servoId]?.min}-${servoLimits[servoId]?.max})`);
            if (!isAnimating) {
                console.log(`Animation stopped before updating servo ${servoId}`);
                return;
            }
            
            // Animate URDF model smoothly and wait for completion
            await animateURDFServo(servoId, targetValue, 300);
            
            // Only send to device if connected
            if (isConnected) {
            try {
                await fetchWithTimeout('http://localhost:8000/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ positions: { [servoId]: targetValue } })
                }, 5000);
                    console.log(`Successfully sent ${servoId} = ${targetValue} to device`);
            } catch (err) {
                console.error(`Error updating servo ${servoId}:`, err);
                throw err;
                }
            } else {
            }
        }

        async function runAnimationPhase(steps, phaseName) {
            console.log(`Starting ${phaseName} phase with ${steps.length} steps`);
            const delayBetweenJoints = settings.animation_stagger_delay;
            
            // Run movements sequentially
            for (let index = 0; index < steps.length; index++) {
                        if (!isAnimating) {
                            console.log(`Animation stopped during ${phaseName} phase at step ${index}`);
                    break;
                        }
                
                const step = steps[index];
                console.log(`${phaseName} step ${index + 1}/${steps.length}: ${step.servo} -> ${step.value}`);
                        try {
                            await updateServo(step.servo, step.value);
                    
                    // Add delay between movements for smooth animation
                    if (index < steps.length - 1) {
                        let extraDelay = 0;
                        // Add extra delay for index and thumb servos to make sure they reach limits
                        if (['servo_6', 'servo_8', 'servo_9', 'servo_10', 'servo_12'].includes(step.servo)) {
                            extraDelay = 200;
                            console.log(`Adding extra delay of ${extraDelay}ms for ${step.servo}`);
                        }
                        await new Promise(resolve => setTimeout(resolve, delayBetweenJoints + extraDelay));
                    }
                        } catch (err) {
                            console.error(`Error in ${phaseName} phase at step ${index}:`, err);
                }
            }
            console.log(`Completed ${phaseName} phase`);
        }

        async function runAnimation() {
            console.log('Starting animation');
            isAnimating = true;

            try {
                // Define finger servos (excluding thumb-related servos)
                const fingerServos = Object.keys(servoLimits).filter(servo => 
                    !['servo_9', 'servo_10', 'servo_12'].includes(servo)
                ).sort((a, b) => {
                    const order = ['servo_7', 'servo_1', 'servo_3', 'servo_2', 'servo_4', 'servo_5', 'servo_8', 'servo_6'];
                    return order.indexOf(a) - order.indexOf(b);
                });

                console.log('Finger servos for animation:', fingerServos);
                console.log('Servo limits:', servoLimits);

                // Define thumb servos
                const thumbServos = ['servo_12', 'servo_9', 'servo_10'];
                console.log('Thumb servos for animation:', thumbServos);

                // Closing phase: Move all finger servos to max positions
                const closeSteps = fingerServos.map(servo => ({
                    servo,
                    value: servoLimits[servo].max
                }));
                console.log('Closing steps:', closeSteps);

                await runAnimationPhase(closeSteps, 'closing');

                // Opening phase: Move all finger servos to min positions in reverse order
                const openSteps = fingerServos.slice().reverse().map(servo => ({
                    servo,
                    value: servoLimits[servo].min
                }));
                console.log('Opening steps:', openSteps);

                await runAnimationPhase(openSteps, 'opening');

                // Thumb closing phase
                const thumbCloseSteps = thumbServos.map(servo => ({
                    servo,
                    value: servoLimits[servo].max
                }));
                console.log('Thumb closing steps:', thumbCloseSteps);

                await runAnimationPhase(thumbCloseSteps, 'thumb closing');

                // Thumb opening phase
                const thumbOpenSteps = thumbServos.slice().reverse().map(servo => ({
                    servo,
                    value: servoLimits[servo].min
                }));
                console.log('Thumb opening steps:', thumbOpenSteps);

                await runAnimationPhase(thumbOpenSteps, 'thumb opening');

                // Loop if checked
                if (isAnimating && loopAnimationCheckbox.checked) {
                    console.log('Looping animation');
                    runAnimation();
                } else {
                    console.log('Animation completed');
                    isAnimating = false;
                    setTimeout(() => {
                        resetDIPJoints();
                    }, 100);
                }
            } catch (err) {
                console.error('Animation failed:', err);
                isAnimating = false;
            }
        }

        startAnimationBtn.addEventListener('click', () => {
            if (!isAnimating) {
                runAnimation();
            } else {
                console.log('Animation already running');
            }
        });

        stopAnimationBtn.addEventListener('click', stopAnimation);

        function stopAnimation() {
            console.log('Stopping animation');
            isAnimating = false;
            if (animationTimeout) {
                clearTimeout(animationTimeout);
                animationTimeout = null;
            }
        }

        // Add and Remove Gestures
        function updateGestureDropdown() {
            console.log('Updating gesture dropdown');
            fetch('http://localhost:8000/gestures')
                .then(response => response.json())
                .then(data => {
                    const select = document.getElementById('gesture');
                    select.innerHTML = '';
                    
                    // Add default option
                    const defaultOption = document.createElement('option');
                    defaultOption.value = '';
                    defaultOption.textContent = 'Default Position';
                    select.appendChild(defaultOption);
                    
                    const gestures = Object.keys(data.gestures).sort(); // Sort alphabetically
                    gestures.forEach(gesture => {
                        const option = document.createElement('option');
                        option.value = gesture;
                        option.textContent = gesture.charAt(0).toUpperCase() + gesture.slice(1).replace('_', ' ');
                        select.appendChild(option);
                    });
                })
                .catch(err => console.error('Error updating gesture dropdown:', err));
        }

        addGestureBtn.addEventListener('click', async () => {
            console.log('Adding new gesture');
            const gestureName = newGestureNameInput.value.trim();
            if (!gestureName) {
                alert('Please enter a gesture name.');
                return;
            }

            try {
                await fetchWithTimeout('http://localhost:8000/add_gesture', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ gesture: gestureName.toLowerCase().replace(' ', '_') })
                }, 5000);

                updateGestureDropdown();
                updateGestureButtons();
                newGestureNameInput.value = '';
                alert(`Gesture "${gestureName}" added!`);
            } catch (err) {
                console.error('Error adding gesture:', err);
            }
        });

        removeGestureBtn.addEventListener('click', async () => {
            console.log('Removing gesture');
            const gesture = document.getElementById('gesture').value;
            if (!gesture) {
                alert('Please select a gesture to remove.');
                return;
            }
            if (confirm(`Are you sure you want to remove the gesture "${gesture}"?`)) {
                try {
                    await fetchWithTimeout('http://localhost:8000/remove_gesture', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ gesture })
                    }, 5000);

                    updateGestureDropdown();
                    updateGestureButtons();
                    updateSequenceList();
                    alert(`Gesture "${gesture}" removed!`);
                } catch (err) {
                    console.error('Error removing gesture:', err);
                }
            }
        });

        // Rename gesture functionality
        renameGestureBtn.addEventListener('click', async () => {
            console.log('Renaming gesture');
            const gesture = document.getElementById('gesture').value;
            if (!gesture) {
                alert('Please select a gesture to rename.');
                return;
            }
            
            const newName = prompt(`Enter new name for gesture "${gesture}":`, gesture);
            if (newName && newName.trim() && newName !== gesture) {
                try {
                    await fetchWithTimeout('http://localhost:8000/rename_gesture', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            oldName: gesture, 
                            newName: newName.toLowerCase().replace(' ', '_') 
                        })
                    }, 5000);

                    updateGestureDropdown();
                    updateGestureButtons();
                    updateSequenceList();
                    alert(`Gesture "${gesture}" renamed to "${newName}"!`);
                } catch (err) {
                    console.error('Error renaming gesture:', err);
                }
            }
        });

        // Duplicate gesture functionality
        duplicateGestureBtn.addEventListener('click', async () => {
            console.log('Duplicating gesture');
            const gesture = document.getElementById('gesture').value;
            if (!gesture) {
                alert('Please select a gesture to duplicate.');
                return;
            }
            
            const newName = prompt(`Enter name for the duplicate of "${gesture}":`, `${gesture}_copy`);
            if (newName && newName.trim()) {
                try {
                    await fetchWithTimeout('http://localhost:8000/duplicate_gesture', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            originalGesture: gesture, 
                            newGesture: newName.toLowerCase().replace(' ', '_') 
                        })
                    }, 5000);

                    updateGestureDropdown();
                    updateGestureButtons();
                    updateSequenceList();
                    alert(`Gesture "${gesture}" duplicated as "${newName}"!`);
                } catch (err) {
                    console.error('Error duplicating gesture:', err);
                }
            }
        });

        // Export gestures functionality
        exportGesturesBtn.addEventListener('click', async () => {
            console.log('Exporting gestures');
            try {
                const response = await fetchWithTimeout('http://localhost:8000/gestures', {}, 5000);
                const data = await response.json();
                
                const exportData = {
                    gestures: data.gestures,
                    sequences: data.sequences || {},
                    exportDate: new Date().toISOString(),
                    version: '1.0'
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `gestures_export_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert('Gestures exported successfully!');
            } catch (err) {
                console.error('Error exporting gestures:', err);
                alert('Error exporting gestures.');
            }
        });

        // Import gestures functionality
        importGesturesBtn.addEventListener('click', async () => {
            console.log('Importing gestures');
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const text = await file.text();
                        const importData = JSON.parse(text);
                        
                        if (confirm(`Import ${Object.keys(importData.gestures || {}).length} gestures and ${Object.keys(importData.sequences || {}).length} sequences?`)) {
                            await fetchWithTimeout('http://localhost:8000/import_gestures', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(importData)
                            }, 5000);

                            updateGestureDropdown();
                            updateGestureButtons();
                            updateSequenceList();
                            alert('Gestures imported successfully!');
                        }
                    } catch (err) {
                        console.error('Error importing gestures:', err);
                        alert('Error importing gestures. Please check the file format.');
                    }
                }
            };
            input.click();
        });

        // Fetch servo limits from the server
        async function fetchServoLimits() {
            console.log('Fetching servo limits');
            try {
                const response = await fetchWithTimeout('http://localhost:8000/servo_limits', {}, 5000);
                servoLimits = await response.json();
                initializeSliders();
                initializeSettings();
            } catch (err) {
                console.error('Error fetching servo limits:', err);
            }
        }

        // Fetch settings from the server
        async function fetchSettings() {
            console.log('Fetching settings');
            try {
                const response = await fetchWithTimeout('http://localhost:8000/settings', {}, 5000);
                settings = await response.json();
                initializeSettings();
                await fetchAvailablePorts();
            } catch (err) {
                console.error('Error fetching settings:', err);
            }
        }

        // Initialize sliders with fetched limits
        function initializeSliders() {
            console.log('Initializing sliders with servo limits');
            const servoSliders = document.querySelectorAll('input[type="range"]');
            servoSliders.forEach(slider => {
                const servoId = slider.id;
                if (servoLimits[servoId]) {
                    slider.min = servoLimits[servoId].min;
                    slider.max = servoLimits[servoId].max;
                    const defaultPosition = getDefaultPosition(servoId);
                    slider.value = defaultPosition;
                    document.getElementById(`${servoId}_limits`).textContent = `[${servoLimits[servoId].min} - ${servoLimits[servoId].max}]`;
                    document.getElementById(`${servoId}_value`).textContent = defaultPosition;
                    
                    // Add hover effects for joint highlighting
                    const jointName = jointMapping[servoId];
                    if (jointName) {
                        slider.addEventListener('mouseenter', () => {
                            if (urdfViewer && urdfViewer.robot && urdfViewer.robot.joints[jointName]) {
                                urdfViewer.robot.joints[jointName].highlight = true;
                                urdfViewer.render();
                            }
                        });
                        
                        slider.addEventListener('mouseleave', () => {
                            if (urdfViewer && urdfViewer.robot && urdfViewer.robot.joints[jointName]) {
                                // Remove highlight
                                urdfViewer.robot.joints[jointName].highlight = false;
                                urdfViewer.render();
                            }
                        });
                    }
                }
            });
        }

        // Initialize settings page
        function initializeSettings() {
            console.log('Initializing settings page');
            // Servo limits
            servoLimitsControls.innerHTML = '';
            for (const servoId in servoLimits) {
                const controlDiv = document.createElement('div');
                controlDiv.className = 'servo-limit-control';
                controlDiv.innerHTML = `
                    <label>${document.querySelector(`#${servoId}`).parentElement.querySelector('label').textContent}</label>
                    <input type="number" class="servo-min" data-servo="${servoId}" value="${servoLimits[servoId].min}" min="0" step="1">
                    <input type="number" class="servo-max" data-servo="${servoId}" value="${servoLimits[servoId].max}" min="0" step="1">
                `;
                servoLimitsControls.appendChild(controlDiv);
            }
            // Other settings
            animationStaggerDelayInput.value = settings.animation_stagger_delay || 60;
            defaultSequenceStepDelayInput.value = settings.default_sequence_step_delay || 2000;
            defaultPositionOffsetInput.value = settings.default_position_offset || 60;
        }

        // Save settings
        saveSettingsBtn.addEventListener('click', async () => {
            console.log('Saving settings');
            // Save servo limits
            const newServoLimits = {};
            const minInputs = document.querySelectorAll('.servo-min');
            const maxInputs = document.querySelectorAll('.servo-max');
            for (let i = 0; i < minInputs.length; i++) {
                const servoId = minInputs[i].dataset.servo;
                const minValue = parseInt(minInputs[i].value);
                const maxValue = parseInt(maxInputs[i].value);
                if (minValue <= maxValue) {
                    newServoLimits[servoId] = { min: minValue, max: maxValue };
                } else {
                    alert(`Min value for ${servoId} must be less than or equal to max value.`);
                    return;
                }
            }
            try {
                await fetchWithTimeout('http://localhost:8000/update_servo_limits', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(newServoLimits)
                }, 5000);
                servoLimits = newServoLimits;
                initializeSliders();
            } catch (err) {
                console.error('Error saving servo limits:', err);
                return;
            }

            // Save other settings
            const newSettings = {
                animation_stagger_delay: parseInt(animationStaggerDelayInput.value) || 60,
                default_sequence_step_delay: parseInt(defaultSequenceStepDelayInput.value) || 2000,
                default_position_offset: parseInt(defaultPositionOffsetInput.value) || 60,
                device_name: settings.device_name
            };
            try {
                await fetchWithTimeout('http://localhost:8000/update_settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(newSettings)
                }, 5000);
                settings = newSettings;
                alert('Settings saved!');
            } catch (err) {
                console.error('Error saving settings:', err);
            }
        });

        // Fetch available ports
        async function fetchAvailablePorts() {
            console.log('Fetching available ports');
            try {
                const response = await fetchWithTimeout('http://localhost:8000/available_ports', {}, 5000);
                const ports = await response.json();
                deviceSelect.innerHTML = '<option value="">Select a device</option>';
                ports.forEach(port => {
                    const option = document.createElement('option');
                    option.value = port;
                    option.textContent = port;
                    deviceSelect.appendChild(option);
                });
                // Select the device from settings if available
                if (settings.device_name && ports.includes(settings.device_name)) {
                    deviceSelect.value = settings.device_name;
                }
            } catch (err) {
                console.error('Error fetching available ports:', err);
            }
        }

        // Thumb clearance checkbox event listener
        thumbClearanceCheckbox.addEventListener('change', () => {
            thumbClearanceEnabled = thumbClearanceCheckbox.checked;
            console.log('Thumb clearance enabled:', thumbClearanceEnabled);
        });

        // Connect to device
        connectBtn.addEventListener('click', async () => {
            const deviceName = deviceSelect.value;
            if (!deviceName) {
                alert('Please select a device to connect.');
                return;
            }
            console.log(`Attempting to connect to ${deviceName}`);
            try {
                const response = await fetchWithTimeout('http://localhost:8000/connect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ device_name: deviceName })
                }, 5000);
                const result = await response.json();
                if (response.ok) {
                    isConnected = true;
                    connectBtn.classList.add('connected');
                    connectBtn.textContent = 'Connected';
                    console.log(result.message);
                    // Update settings with selected device
                    settings.device_name = deviceName;
                    await fetchWithTimeout('http://localhost:8000/update_settings', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(settings)
                    }, 5000);
                } else {
                    isConnected = false;
                    connectBtn.classList.remove('connected');
                    connectBtn.textContent = 'Connect';
                    console.error(result.message);
                    alert(result.message);
                }
            } catch (err) {
                isConnected = false;
                connectBtn.classList.remove('connected');
                connectBtn.textContent = 'Connect';
                console.error('Error connecting to device:', err);
                alert('Failed to connect to device.');
            }
        });

        // Initial load
        console.log('Initializing UI');
        
        // Test URDF endpoint
                    fetch('descriptions/RoninHand.urdf')
            .then(response => {
                if (response.ok) {
                    console.log('URDF file accessible');
                    return response.text();
                } else {
                    console.error('URDF file not accessible:', response.status);
                    throw new Error('URDF not accessible');
                }
            })
            .then(urdfContent => {
                console.log('URDF content length:', urdfContent.length);
                if (urdfContent.includes('RoninHand')) {
                    console.log('URDF file appears to be valid');
                } else {
                    console.warn('URDF content may be invalid');
                }
            })
            .catch(err => {
                console.error('Error accessing URDF file:', err);
                // Show fallback if server is not accessible
                setTimeout(() => {
                    document.getElementById('urdf-fallback').style.display = 'block';
                }, 2000);
            });
        
        initializeApp();

        // Load available cameras
        async function loadAvailableCameras() {
            try {
                // Request camera permission first
                await navigator.mediaDevices.getUserMedia({ video: true });
                
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                cameraSelect.innerHTML = '<option value="">Select a camera</option>';
                
                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Camera ${index + 1}`;
                    cameraSelect.appendChild(option);
                });
                
                // Auto-select the first camera
                if (videoDevices.length > 0) {
                    cameraSelect.value = videoDevices[0].deviceId;
                    console.log('Auto-selected first camera:', videoDevices[0].label || 'Camera 1');
                }
                
                console.log('Available cameras loaded:', videoDevices.length);
            } catch (error) {
                console.error('Error loading cameras:', error);
                alert('Failed to access cameras. Please ensure camera permissions are granted.');
            }
        }

        // Refresh cameras
        async function refreshCameras() {
            try {
                await loadAvailableCameras();
            } catch (error) {
                console.error('Error refreshing cameras:', error);
                alert('Failed to access cameras. Please ensure camera permissions are granted.');
            }
        }

        // Start camera with selected device
        async function startCameraWithDevice(deviceId) {
            try {
                const constraints = {
                    video: {
                        deviceId: deviceId ? { exact: deviceId } : undefined,
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        frameRate: { ideal: 30 }
                    }
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Create video element
                const video = document.createElement('video');
                video.srcObject = stream;
                video.width = 640;
                video.height = 480;
                video.autoplay = true;
                video.muted = true;
                video.playsInline = true;
                video.style.display = 'none';
                
                // Wait for video to be ready
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        console.log('Video metadata loaded, starting playback');
                        video.play();
                        resolve();
                    };
                });
                
                console.log('Video element ready, dimensions:', video.videoWidth, 'x', video.videoHeight);
                
                // Set up camera with video element for real-time processing
                camera = new Camera(video, {
                    onFrame: async () => {
                        if (hands && isTrackingActive) {
                            try {
                                await hands.send({ image: video });
                            } catch (error) {
                                console.error('Error sending frame to MediaPipe:', error);
                            }
                        }
                    },
                    width: 640,
                    height: 480
                });
                
                // Store video reference for canvas drawing
                camera.video = video;
                
                // Start real-time processing
                camera.start();
                
                console.log('Camera started with device:', deviceId);
                
            } catch (error) {
                console.error('Error starting camera:', error);
                alert('Failed to start camera. Please check camera permissions and try again.');
            }
        }
    </script>

    <!-- Hand Tracking Functions -->
    <script>
        // Hand tracking to servo mapping
        const handToServoMapping = {
            // Finger PIP joints (bend) - Using finger tips for better control
            'pinky_pip': { servo: 'servo_1', landmarks: [17, 18, 20], type: 'bend' }, // Pinky: base to tip
            'ring_pip': { servo: 'servo_2', landmarks: [13, 14, 16], type: 'bend' }, // Ring: base to tip
            'middle_pip': { servo: 'servo_5', landmarks: [9, 10, 12], type: 'bend' }, // Middle: base to tip
            'index_pip': { servo: 'servo_6', landmarks: [5, 6, 8], type: 'bend' }, // Index: base to tip
            
            // Finger MCP joints (bend) - Using wrist to finger base angle
            'pinky_mcp': { servo: 'servo_7', landmarks: [0, 17, 18], type: 'bend' }, // Pinky MCP: wrist to base
            'ring_mcp': { servo: 'servo_3', landmarks: [0, 13, 14], type: 'bend' }, // Ring MCP: wrist to base
            'middle_mcp': { servo: 'servo_4', landmarks: [0, 9, 10], type: 'bend' }, // Middle MCP: wrist to base
            'index_mcp': { servo: 'servo_8', landmarks: [0, 5, 6], type: 'bend' }, // Index MCP: wrist to base
            
            // Thumb joints - Fixed with proper landmarks
            'thumb_mcp': { servo: 'servo_9', landmarks: [2, 3, 4], type: 'bend' }, // Thumb MCP: base to tip
            'thumb_pip': { servo: 'servo_10', landmarks: [3, 4, 5], type: 'bend' }, // Thumb PIP: first to tip
            'thumb_abduction': { servo: 'servo_12', landmarks: [1, 2], type: 'spread' } // Thumb abduction
        };

        // Initialize hand tracking
        function initializeHandTracking() {
            console.log('Initializing hand tracking...');
            
            // Check if MediaPipe is available
            if (typeof Hands === 'undefined') {
                console.error('MediaPipe Hands not loaded');
                alert('MediaPipe Hands library failed to load. Please check your internet connection.');
                return;
            }
            
            try {
                // Get canvas for drawing
                const canvas = document.getElementById('camera-canvas');
                const ctx = canvas.getContext('2d');
                
                // Initialize MediaPipe Hands with better error handling
                hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
                    }
                });

                console.log('MediaPipe Hands initialized');

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.7
                });

                console.log('MediaPipe Hands options set');

                hands.onResults((results) => {
                    // Clear canvas first
                    const canvas = document.getElementById('camera-canvas');
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw video frame first
                    if (camera && camera.video) {
                        try {
                            ctx.drawImage(camera.video, 0, 0, canvas.width, canvas.height);
                            
                            // Update camera overlay
                            const overlay = document.getElementById('camera-overlay');
                            if (overlay) {
                                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                                    overlay.textContent = `${results.multiHandLandmarks.length} Hand(s) Detected`;
                                    overlay.style.background = 'rgba(40, 167, 69, 0.8)';
                                } else {
                                    overlay.textContent = 'No Hand Detected';
                                    overlay.style.background = 'rgba(220, 53, 69, 0.8)';
                                }
                            }
                        } catch (error) {
                            console.log('Error drawing video frame:', error);
                        }
                    }
                    
                    ctx.save();
                    
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        console.log('Drawing hand landmarks:', results.multiHandLandmarks.length, 'hands detected');
                        
                        for (const landmarks of results.multiHandLandmarks) {
                            // Draw hand connections
                            drawHandConnections(ctx, landmarks);
                            // Draw hand landmarks
                            drawHandLandmarks(ctx, landmarks);
                            
                            // Draw contact indicators if available
                            if (lastHandLandmarks) {
                                const contacts = detectThumbContacts(lastHandLandmarks);
                                drawContactIndicators(ctx, lastHandLandmarks, contacts);
                            }
                        }
                    } else {
                        console.log('No hand landmarks detected');
                    }
                    
                    ctx.restore();
                    
                    // Process hand tracking results
                    onHandResults(results);
                });

                // Initialize UI controls
                initializeHandTrackingControls();
                
                // Load calibration from JSON
                loadCalibrationFromJSON();
                
                // Load available cameras
                loadAvailableCameras();
                
                // Initialize joint mapping preview
                updateJointMappingPreviewFromCalibration();
                
                // Apply manual calibration for problematic joints
                calibrateProblematicJoints();
                
                console.log('Hand tracking initialized successfully');
            } catch (error) {
                console.error('Failed to initialize hand tracking:', error);
                alert('Failed to initialize MediaPipe hand tracking. Please check your internet connection and try again.');
            }
        }

        // Initialize hand tracking controls
        function initializeHandTrackingControls() {
            // Update settings sliders
            smoothingFactor.addEventListener('input', () => {
                handTrackingSettings.smoothingFactor = parseFloat(smoothingFactor.value);
                smoothingValue.textContent = handTrackingSettings.smoothingFactor.toFixed(1);
            });

            responseSpeed.addEventListener('input', () => {
                handTrackingSettings.responseSpeed = parseFloat(responseSpeed.value);
                responseValue.textContent = handTrackingSettings.responseSpeed.toFixed(1);
            });

            deadZone.addEventListener('input', () => {
                handTrackingSettings.deadZone = parseFloat(deadZone.value);
                deadZoneValue.textContent = handTrackingSettings.deadZone.toFixed(2);
            });

            // Start/Stop tracking buttons
            startTrackingBtn.addEventListener('click', startHandTracking);
            stopTrackingBtn.addEventListener('click', stopHandTracking);

            // Camera selection
            refreshCamerasBtn.addEventListener('click', refreshCameras);
            cameraSelect.addEventListener('change', () => {
                const selectedDeviceId = cameraSelect.value;
                if (selectedDeviceId && isTrackingActive) {
                    // Restart camera with new device
                    stopHandTracking();
                    setTimeout(() => {
                        startCameraWithDevice(selectedDeviceId).then(() => {
                            startHandTracking();
                        });
                    }, 500);
                }
            });

            // Calibration buttons
            calibrateHandBtn.addEventListener('click', startHandCalibration);
            resetCalibrationBtn.addEventListener('click', resetHandCalibration);

            // Update calibration status
            updateCalibrationStatus();
        }

        // Start hand tracking
        async function startHandTracking() {
            if (isTrackingActive) return;
            
            console.log('Starting hand tracking...');
            try {
                // Reset Kalman filters for fresh tracking
                resetKalmanFilters();
                
                const selectedDeviceId = cameraSelect.value;
                
                if (!selectedDeviceId) {
                    alert('Please select a camera first.');
                    return;
                }
                
                // Start camera with selected device
                await startCameraWithDevice(selectedDeviceId);
                
                isTrackingActive = true;
                startTrackingBtn.style.display = 'none';
                stopTrackingBtn.style.display = 'inline-block';
                
                console.log('Hand tracking started');
                
                // Load calibration from JSON
                await loadCalibrationFromJSON();
                
                // Ensure URDF model integrity
                ensureURDFIntegrity();
                
                // Auto-calibrate if not calibrated
                setTimeout(() => {
                    autoCalibrate();
                }, 1000);
                
            } catch (error) {
                console.error('Failed to start hand tracking:', error);
                alert('Failed to start hand tracking. Please ensure camera access is granted.');
            }
        }

        // Stop hand tracking
        function stopHandTracking() {
            if (!isTrackingActive) return;
            
            console.log('Stopping hand tracking...');
            
            // Stop camera stream
            if (camera && camera.video && camera.video.srcObject) {
                const stream = camera.video.srcObject;
                const tracks = stream.getTracks();
                tracks.forEach(track => track.stop());
                console.log('Camera stream stopped');
            }
            
            if (camera) {
                camera.stop();
            }
            
            // Clear canvas
            const canvas = document.getElementById('camera-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            isTrackingActive = false;
            startTrackingBtn.style.display = 'inline-block';
            stopTrackingBtn.style.display = 'none';
            console.log('Hand tracking stopped');
            
            // Reset URDF model to default positions
            if (urdfLoader && urdfLoader.robot) {
                const defaultPositions = {};
                for (const servoId in servoLimits) {
                    defaultPositions[servoId] = getDefaultPosition(servoId);
                }
                animateURDFModel(defaultPositions, 500);
            }
        }

        // Handle hand tracking results
        function onHandResults(results) {
            if (!isTrackingActive) return;
            
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                console.log('No hand detected');
                return;
            }

            const rawLandmarks = results.multiHandLandmarks[0];
            
            // Apply Kalman filtering to smooth landmarks
            const smoothedLandmarks = [];
            for (let i = 0; i < rawLandmarks.length; i++) {
                try {
                    const landmark = rawLandmarks[i];
                    const measurement = [landmark.x, landmark.y, landmark.z];
                    
                    // Predict and update with Kalman filter
                    kalmanFilters[i].predict();
                    const smoothed = kalmanFilters[i].update(measurement);
                    
                    // Create smoothed landmark object
                    smoothedLandmarks.push({
                        x: smoothed[0],
                        y: smoothed[1],
                        z: smoothed[2]
                    });
                } catch (error) {
                    console.warn(`Error processing landmark ${i}:`, error);
                    // Fallback to original landmark if Kalman filter fails
                    const landmark = rawLandmarks[i];
                    smoothedLandmarks.push({
                        x: landmark.x,
                        y: landmark.y,
                        z: landmark.z
                    });
                }
            }
            
            lastHandLandmarks = smoothedLandmarks;

            console.log('Processing hand landmarks, count:', smoothedLandmarks.length);

            // Process hand landmarks and map to servo positions
            const servoPositions = mapHandLandmarksToServos(smoothedLandmarks);
            
            console.log('Hand tracking servo positions:', servoPositions);
            
            // Update URDF model and send to servos
            updateServosFromHandTracking(servoPositions);
            
            // Update joint mapping preview
            updateJointMappingPreview(servoPositions);
            
            // Detect contacts and classify gesture
            const contacts = detectThumbContacts(smoothedLandmarks);
            const gesture = classifyGesture(smoothedLandmarks);
            
            // Update tracking details with gesture information
            const trackingDetails = document.getElementById('tracking-details');
            if (trackingDetails) {
                const contactInfo = Object.entries(contacts)
                    .filter(([_, isContact]) => isContact)
                    .map(([finger, _]) => finger)
                    .join(', ');
                const gestureInfo = gesture !== 'none' ? ` - ${gesture}` : '';
                trackingDetails.textContent = `Processing ${smoothedLandmarks.length} landmarks with Kalman filtering${gestureInfo}`;
            }
            
                        // Log gesture and contact information
            console.log('Gesture:', gesture, 'Contacts:', contacts);
            
            // Log smoothing statistics for debugging
            if (smoothedLandmarks.length > 0) {
                const thumbTip = smoothedLandmarks[4];
                if (thumbTip) {
                    console.log('Smoothed thumb tip position:', {
                        x: thumbTip.x.toFixed(4),
                        y: thumbTip.y.toFixed(4),
                        z: thumbTip.z.toFixed(4)
                    });
                }
            }
        }
        
        // Draw contact indicators when thumb touches other fingers
        function drawContactIndicators(ctx, landmarks, contacts) {
            if (!contacts || !landmarks) return;
            
            const thumbTip = landmarks[4];
            if (!thumbTip) return;
            
            const fingerTips = {
                index: landmarks[8],
                middle: landmarks[12],
                ring: landmarks[16],
                pinky: landmarks[20]
            };
            
            for (const [finger, tip] of Object.entries(fingerTips)) {
                if (contacts[finger] && tip) {
                    // Draw contact indicator
                    const x = tip.x * ctx.canvas.width;
                    const y = tip.y * ctx.canvas.height;
                    
                    // Draw a subtle contact indicator
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.6)';
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw connection line between thumb and finger
                    const thumbX = thumbTip.x * ctx.canvas.width;
                    const thumbY = thumbTip.y * ctx.canvas.height;
                    
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(thumbX, thumbY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                }
            }
        }
        
        // Map hand landmarks to servo positions
        function mapHandLandmarksToServos(landmarks) {
            const servoPositions = {};
            
            console.log('Mapping landmarks to servos, landmarks count:', landmarks.length);
            
            for (const [jointName, mapping] of Object.entries(handToServoMapping)) {
                const servoId = mapping.servo;
                const limits = servoLimits[servoId];
                
                if (!limits) {
                    console.warn(`No limits found for servo ${servoId}`);
                    continue;
                }
                
                let value = 0;
                
                try {
                    if (mapping.type === 'bend') {
                        // Calculate finger bend angle
                        const [p1, p2, p3] = mapping.landmarks;
                        if (landmarks[p1] && landmarks[p2] && landmarks[p3]) {
                            const angle = calculateBendAngle(landmarks[p1], landmarks[p2], landmarks[p3]);
                            value = mapAngleToServoPosition(angle, limits, jointName);
                            console.log(`${jointName} bend angle: ${angle.toFixed(3)}, mapped to: ${value}`);
                        } else {
                            console.warn(`Missing landmarks for ${jointName}:`, { p1, p2, p3 });
                        }
                    } else if (mapping.type === 'spread') {
                        // Calculate finger spread
                        const [p1, p2] = mapping.landmarks;
                        if (landmarks[p1] && landmarks[p2]) {
                            const spread = calculateSpread(landmarks[p1], landmarks[p2]);
                            value = mapSpreadToServoPosition(spread, limits, jointName);
                            console.log(`${jointName} spread: ${spread.toFixed(3)}, mapped to: ${value}`);
                        } else {
                            console.warn(`Missing landmarks for ${jointName}:`, { p1, p2 });
                        }
                    } else if (mapping.type === 'mcp_bend') {
                        // Calculate MCP bend using base to tip distance
                        const [p1, p2] = mapping.landmarks;
                        if (landmarks[p1] && landmarks[p2]) {
                            const mcpBend = calculateMcpBend(landmarks[p1], landmarks[p2]);
                            value = mapMcpBendToServoPosition(mcpBend, limits, jointName);
                            console.log(`${jointName} MCP bend: ${mcpBend.toFixed(3)}, mapped to: ${value}`);
                        } else {
                            console.warn(`Missing landmarks for ${jointName}:`, { p1, p2 });
                        }
                    }
                } catch (error) {
                    console.error(`Error calculating ${jointName}:`, error);
                }
                
                // Apply smoothing
                if (smoothedJointValues[jointName] !== undefined) {
                    const smoothing = handTrackingSettings.smoothingFactor;
                    value = smoothedJointValues[jointName] * (1 - smoothing) + value * smoothing;
                }
                
                // Apply dead zone
                const center = (limits.max + limits.min) / 2;
                const range = limits.max - limits.min;
                const deadZoneRange = range * handTrackingSettings.deadZone;
                
                if (Math.abs(value - center) < deadZoneRange) {
                    value = center;
                }
                
                smoothedJointValues[jointName] = value;
                servoPositions[servoId] = Math.round(value);
                
                console.log(`${jointName} (${servoId}): ${value} (limits: ${limits.min}-${limits.max})`);
                
                // Special debugging for problematic joints
                if (jointName.includes('index_mcp') || jointName.includes('thumb')) {
                    console.log(`DEBUG ${jointName}: landmarks=${mapping.landmarks}, type=${mapping.type}, raw_value=${value}`);
                }
            }
            
            return servoPositions;
                }
        
        // Draw hand outline/silhouette for better visual feedback
        function drawHandOutline(ctx, landmarks) {
            if (landmarks.length < 21) return;
            
            // Create a subtle outline around the hand
            const outlinePoints = [];
            
            // Define outline path using key landmarks
            const outlineIndices = [
                0,   // Wrist
                5,   // Index MCP
                9,   // Middle MCP
                13,  // Ring MCP
                17,  // Pinky MCP
                20,  // Pinky tip
                19,  // Pinky DIP
                18,  // Pinky PIP
                17,  // Pinky MCP
                13,  // Ring MCP
                16,  // Ring tip
                15,  // Ring DIP
                14,  // Ring PIP
                13,  // Ring MCP
                9,   // Middle MCP
                12,  // Middle tip
                11,  // Middle DIP
                10,  // Middle PIP
                9,   // Middle MCP
                5,   // Index MCP
                8,   // Index tip
                7,   // Index DIP
                6,   // Index PIP
                5,   // Index MCP
                1,   // Thumb CMC
                2,   // Thumb MCP
                3,   // Thumb PIP
                4,   // Thumb tip
                3,   // Thumb PIP
                2,   // Thumb MCP
                1,   // Thumb CMC
                0    // Back to wrist
            ];
            
            // Build outline path
            for (const index of outlineIndices) {
                if (landmarks[index]) {
                    const x = landmarks[index].x * ctx.canvas.width;
                    const y = landmarks[index].y * ctx.canvas.height;
                    outlinePoints.push({ x, y });
                }
            }
            
            if (outlinePoints.length > 2) {
                // Draw subtle outline
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(outlinePoints[0].x, outlinePoints[0].y);
                for (let i = 1; i < outlinePoints.length; i++) {
                    ctx.lineTo(outlinePoints[i].x, outlinePoints[i].y);
                }
                ctx.closePath();
                ctx.stroke();
            }
        }
        
        // Calculate bend angle between three points with improved accuracy
        function calculateBendAngle(p1, p2, p3) {
            const v1 = { x: p1.x - p2.x, y: p1.y - p2.y, z: p1.z - p2.z };
            const v2 = { x: p3.x - p2.x, y: p3.y - p2.y, z: p3.z - p2.z };
            
            const dot = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
            const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);
            const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z);
            
            if (mag1 === 0 || mag2 === 0) return 0;
            
            const angle = Math.acos(Math.max(-1, Math.min(1, dot / (mag1 * mag2))));
            
            // Improved normalization with joint-specific scaling
            let scale = 1.5; // Default scale for fingers
            
            // Detect which joint this is based on landmark positions
            if (p1.z > 0.5) {
                // Thumb joints need more sensitivity
                scale = 2.5;
            } else if (p1.x > 0.7) {
                // Index finger needs moderate sensitivity
                scale = 1.8;
            } else if (p1.x < 0.3) {
                // Pinky finger needs higher sensitivity
                scale = 2.0;
            }
            
            return Math.min(angle * scale, Math.PI);
        }

        // Calculate spread between two points with improved MCP detection
        function calculateSpread(p1, p2) {
            const distance = Math.sqrt(
                Math.pow(p2.x - p1.x, 2) + 
                Math.pow(p2.y - p1.y, 2) + 
                Math.pow(p2.z - p1.z, 2)
            );
            
            // Use different scaling for different finger spreads
            let scale = 3.0; // Default sensitivity for MCP joints
            
            // Adjust scale based on which fingers are being measured
            if (p1.x < 0.3 && p2.x < 0.3) {
                // Pinky and ring finger spread (closer together)
                scale = 4.0;
            } else if (p1.x > 0.6 && p2.x > 0.6) {
                // Index finger spread (wider range) - improved detection
                scale = 3.5;
            } else if (p1.z > 0.5 || p2.z > 0.5) {
                // Thumb abduction needs higher sensitivity
                scale = 4.5;
            }
            
            // Additional normalization for better range
            const normalizedDistance = Math.min(distance * scale, 0.6);
            
            return normalizedDistance;
        }
        
        // Detect thumb contacts with other fingers
        function detectThumbContacts(landmarks, threshold = 0.01) {
            try {
                const thumbTip = landmarks[4];
                const fingerTips = {
                    index: landmarks[8],
                    middle: landmarks[12],
                    ring: landmarks[16],
                    pinky: landmarks[20]
                };
                
                const contacts = {};
                for (const [finger, tip] of Object.entries(fingerTips)) {
                    if (thumbTip && tip) {
                        const distance = Math.sqrt(
                            Math.pow(tip.x - thumbTip.x, 2) + 
                            Math.pow(tip.y - thumbTip.y, 2) + 
                            Math.pow(tip.z - thumbTip.z, 2)
                        );
                        contacts[finger] = distance < threshold;
                    } else {
                        contacts[finger] = false;
                    }
                }
                return contacts;
            } catch (error) {
                console.warn('Error in detectThumbContacts:', error);
                return { index: false, middle: false, ring: false, pinky: false };
            }
        }
        
        // Classify hand gesture based on contacts
        function classifyGesture(landmarks) {
            try {
                const contacts = detectThumbContacts(landmarks);
                if (contacts.index) {
                    return 'thumb_index_pinch';
                } else if (contacts.middle) {
                    return 'thumb_middle_pinch';
                } else if (contacts.ring) {
                    return 'thumb_ring_pinch';
                } else if (contacts.pinky) {
                    return 'thumb_pinky_pinch';
                }
                return 'none';
            } catch (error) {
                console.warn('Error in classifyGesture:', error);
                return 'none';
            }
        }

        // Map angle to servo position with improved thumb and index handling
        function mapAngleToServoPosition(angle, limits, jointName) {
            // Normalize angle (0 = straight,  = fully bent)
            // For fingers, we want 0 = straight finger, 1 = fully bent
            const normalizedAngle = Math.min(angle / Math.PI, 1.0);
            
            // Invert the mapping so that straight finger = min position, bent finger = max position
            const invertedAngle = 1.0 - normalizedAngle;
            
            // Apply calibration if available
            if (handCalibration.isCalibrated && handCalibration.minValues[jointName] !== undefined) {
                const minAngle = handCalibration.minValues[jointName];
                const maxAngle = handCalibration.maxValues[jointName];
                const angleRange = maxAngle - minAngle;
                
                if (angleRange > 0) {
                    // Map the current angle to the calibrated range
                    const calibratedNormalized = Math.max(0, Math.min(1, (angle - minAngle) / angleRange));
                    const mappedValue = limits.min + (limits.max - limits.min) * (1.0 - calibratedNormalized);
                    return Math.max(limits.min, Math.min(limits.max, mappedValue));
                }
            }
            
            // Special handling for different joint types
            let mappedValue;
            if (jointName.includes('thumb_mcp')) {
                // Thumb MCP needs very sensitive mapping
                const thumbMcpSensitivity = 1.8;
                mappedValue = limits.min + (limits.max - limits.min) * (invertedAngle * thumbMcpSensitivity);
            } else if (jointName.includes('thumb_pip')) {
                // Thumb PIP needs moderate sensitivity
                const thumbPipSensitivity = 1.5;
                mappedValue = limits.min + (limits.max - limits.min) * (invertedAngle * thumbPipSensitivity);
            } else if (jointName.includes('_mcp')) {
                // MCP joints need higher sensitivity and different scaling
                const mcpSensitivity = 2.0;
                mappedValue = limits.min + (limits.max - limits.min) * (invertedAngle * mcpSensitivity);
            } else if (jointName.includes('index')) {
                // Index finger needs higher sensitivity
                const indexSensitivity = 1.4;
                mappedValue = limits.min + (limits.max - limits.min) * (invertedAngle * indexSensitivity);
            } else {
                // Default mapping for other fingers
                mappedValue = limits.min + (limits.max - limits.min) * invertedAngle;
            }
            
            // Clamp to servo limits
            return Math.max(limits.min, Math.min(limits.max, mappedValue));
        }

        // Calculate MCP bend using angle relative to palm
        function calculateMcpBend(p1, p2) {
            // Calculate angle between finger base and tip relative to horizontal
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            
            // Calculate angle in radians
            const angle = Math.atan2(dy, dx);
            
            // Normalize angle to 0-1 range (0 = straight, 1 = fully bent)
            // For MCP, we want to detect when finger is bent downward
            const normalizedAngle = Math.max(0, Math.min(1, (Math.PI/2 - angle) / (Math.PI/2)));
            
            // Add some minimum threshold to prevent stuck at max
            const minBend = 0.1;
            return Math.max(minBend, normalizedAngle);
        }

        // Map MCP bend to servo position
        function mapMcpBendToServoPosition(bendValue, limits, jointName) {
            // Apply calibration if available
            if (handCalibration.isCalibrated && handCalibration.minValues[jointName] !== undefined) {
                const minBend = handCalibration.minValues[jointName];
                const maxBend = handCalibration.maxValues[jointName];
                const bendRange = maxBend - minBend;
                
                if (bendRange > 0) {
                    // Map the current bend to the calibrated range
                    const calibratedNormalized = Math.max(0, Math.min(1, (bendValue - minBend) / bendRange));
                    const mappedValue = limits.min + (limits.max - limits.min) * calibratedNormalized;
                    return Math.max(limits.min, Math.min(limits.max, mappedValue));
                }
            }
            
            // Special handling for different MCP joints
            let mappedValue;
            if (jointName.includes('pinky_mcp')) {
                const pinkySensitivity = 0.8;
                mappedValue = limits.min + (limits.max - limits.min) * (bendValue * pinkySensitivity);
            } else if (jointName.includes('ring_mcp')) {
                const ringSensitivity = 0.8;
                mappedValue = limits.min + (limits.max - limits.min) * (bendValue * ringSensitivity);
            } else if (jointName.includes('middle_mcp')) {
                const middleSensitivity = 0.8;
                mappedValue = limits.min + (limits.max - limits.min) * (bendValue * middleSensitivity);
            } else if (jointName.includes('index_mcp')) {
                // Index MCP needs moderate sensitivity
                const indexSensitivity = 1.0;
                mappedValue = limits.min + (limits.max - limits.min) * (bendValue * indexSensitivity);
            } else if (jointName.includes('thumb_mcp')) {
                // Thumb MCP needs special handling
                const thumbMcpSensitivity = 0.6;
                mappedValue = limits.min + (limits.max - limits.min) * (bendValue * thumbMcpSensitivity);
            } else {
                // Default mapping for other MCP joints
                mappedValue = limits.min + (limits.max - limits.min) * bendValue;
            }
            
            // Clamp to servo limits
            return Math.max(limits.min, Math.min(limits.max, mappedValue));
        }

        // Map spread to servo position with improved MCP handling
        function mapSpreadToServoPosition(spread, limits, jointName) {
            // Normalize spread (0 = closed, 1 = fully spread)
            const normalizedSpread = Math.min(spread / 0.25, 1.0); // Increased threshold for MCP joints
            
            // Apply calibration if available
            if (handCalibration.isCalibrated && handCalibration.minValues[jointName] !== undefined) {
                const minSpread = handCalibration.minValues[jointName];
                const maxSpread = handCalibration.maxValues[jointName];
                const spreadRange = maxSpread - minSpread;
                
                if (spreadRange > 0) {
                    // Map the current spread to the calibrated range
                    const calibratedNormalized = Math.max(0, Math.min(1, (spread - minSpread) / spreadRange));
                    const mappedValue = limits.min + (limits.max - limits.min) * calibratedNormalized;
                    return Math.max(limits.min, Math.min(limits.max, mappedValue));
                }
            }
            
            // Special handling for different MCP joints
            let mappedValue;
            if (jointName.includes('pinky_mcp')) {
                const pinkySensitivity = 1.4;
                mappedValue = limits.min + (limits.max - limits.min) * (normalizedSpread * pinkySensitivity);
            } else if (jointName.includes('ring_mcp')) {
                const ringSensitivity = 1.4;
                mappedValue = limits.min + (limits.max - limits.min) * (normalizedSpread * ringSensitivity);
            } else if (jointName.includes('middle_mcp')) {
                const middleSensitivity = 1.4;
                mappedValue = limits.min + (limits.max - limits.min) * (normalizedSpread * middleSensitivity);
            } else if (jointName.includes('index_mcp')) {
                // Index MCP needs much higher sensitivity
                const indexSensitivity = 2.0;
                mappedValue = limits.min + (limits.max - limits.min) * (normalizedSpread * indexSensitivity);
            } else if (jointName.includes('thumb_abduction')) {
                // Thumb abduction needs very high sensitivity
                const thumbAbductionSensitivity = 2.5;
                mappedValue = limits.min + (limits.max - limits.min) * (normalizedSpread * thumbAbductionSensitivity);
            } else {
                // Default mapping for other joints
                mappedValue = limits.min + (limits.max - limits.min) * normalizedSpread;
            }
            
            // Clamp to servo limits
            return Math.max(limits.min, Math.min(limits.max, mappedValue));
        }

        // Update servos from hand tracking
        function updateServosFromHandTracking(servoPositions) {
            console.log('Updating servos from hand tracking:', servoPositions);
            
            if (!urdfLoader || !urdfLoader.robot) {
                console.error('URDF loader not available');
                return;
            }
            
            // Update URDF model
            for (const [servoId, position] of Object.entries(servoPositions)) {
                const jointName = jointMapping[servoId];
                if (jointName) {
                    try {
                        // Convert servo position to joint angle using calibration
                        const jointAngle = urdfLoader.convertServoPositionWithCalibration(servoId, position, jointName);
                        urdfLoader.setJointValue(jointName, jointAngle);
                        
                        // Move corresponding DIP joint if it exists
                        const dipJointName = dipJointMapping[jointName];
                        if (dipJointName) {
                            urdfLoader.setJointValue(dipJointName, jointAngle);
                        }
                        
                    } catch (error) {
                        console.error(`Error updating joint ${jointName}:`, error);
                    }
                }
            }
            
            // Force URDF render update
            if (urdfLoader.render) {
                urdfLoader.render();
            }
            
            // Send to physical servos if connected
            if (isConnected) {
                sendHandTrackingUpdate(servoPositions);
            }
        }

        // Manual calibration helper for problematic joints
        function calibrateProblematicJoints() {
            console.log('Starting manual calibration for problematic joints...');
            
            // Set up manual calibration for index MCP and thumb joints
            const manualCalibration = {
                'index_mcp': { min: 0.1, max: 0.4 },
                'thumb_mcp': { min: 0.2, max: 1.8 },
                'thumb_pip': { min: 0.3, max: 2.0 },
                'thumb_abduction': { min: 0.1, max: 0.3 }
            };
            
            // Update calibration data
            if (!handCalibration.minValues) handCalibration.minValues = {};
            if (!handCalibration.maxValues) handCalibration.maxValues = {};
            
            for (const [jointName, range] of Object.entries(manualCalibration)) {
                handCalibration.minValues[jointName] = range.min;
                handCalibration.maxValues[jointName] = range.max;
            }
            
            handCalibration.isCalibrated = true;
            console.log('Manual calibration applied for problematic joints');
        }

        // Send hand tracking update to server
        async function sendHandTrackingUpdate(servoPositions) {
            try {
                await fetchWithTimeout('http://localhost:8000/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ positions: servoPositions })
                }, 5000);
            } catch (err) {
                console.error('Error sending hand tracking update:', err);
            }
        }

        // Update joint mapping preview with interactive sliders
        function updateJointMappingPreview(servoPositions) {
            // Throttle updates to prevent flickering during tracking
            if (updateJointMappingPreview.lastUpdate && 
                Date.now() - updateJointMappingPreview.lastUpdate < 200) {
                return;
            }
            updateJointMappingPreview.lastUpdate = Date.now();
            
            jointMappingPreview.innerHTML = '';
            
            for (const [servoId, position] of Object.entries(servoPositions)) {
                const jointName = jointMapping[servoId];
                if (jointName) {
                    const item = document.createElement('div');
                    item.className = 'joint-mapping-item';
                    
                    // Find the corresponding hand tracking mapping
                    const handMapping = Object.entries(handToServoMapping).find(([name, mapping]) => mapping.servo === servoId);
                    const jointType = handMapping ? getJointType(handMapping[0]) : 'default';
                    const limits = servoLimits[servoId] || { min: 0, max: 100 };
                    
                    item.innerHTML = `
                        <div class="joint-header">
                            <span class="joint-name">${jointName} (${servoId})</span>
                        <span class="joint-value">${position}</span>
                        </div>
                        <div class="joint-slider-container">
                            <input type="range" 
                                   class="joint-slider ${jointType}" 
                                   data-joint="${jointName}"
                                   data-servo="${servoId}"
                                   min="${limits.min}" 
                                   max="${limits.max}" 
                                   value="${position}"
                                   step="1">
                            <div class="joint-controls">
                                <button class="test-joint" data-joint="${jointName}" data-servo="${servoId}">Test</button>
                                <button class="reset-joint" data-joint="${jointName}" data-servo="${servoId}">Reset</button>
                                <button class="calibrate-joint" data-joint="${handMapping ? handMapping[0] : ''}">Calibrate</button>
                            </div>
                        </div>
                    `;
                    jointMappingPreview.appendChild(item);
                }
            }
            
            // Add event listeners for interactive controls
            addJointMappingEventListeners();
        }

        // Update joint mapping preview during calibration with interactive sliders
        function updateJointMappingPreviewDuringCalibration(calibrationData) {
            // Throttle updates to prevent flickering
            if (updateJointMappingPreviewDuringCalibration.lastUpdate && 
                Date.now() - updateJointMappingPreviewDuringCalibration.lastUpdate < 500) {
                return;
            }
            updateJointMappingPreviewDuringCalibration.lastUpdate = Date.now();
            
            jointMappingPreview.innerHTML = '';
            
            for (const [jointName, data] of Object.entries(calibrationData)) {
                const item = document.createElement('div');
                item.className = 'joint-mapping-item';
                
                const mapping = handToServoMapping[jointName];
                const jointType = getJointType(jointName);
                const limits = servoLimits[mapping?.servo] || { min: 0, max: 100 };
                
                if (data.min !== Infinity && data.max !== -Infinity) {
                    const avgValue = data.values.length > 0 ? 
                        (data.values.reduce((a, b) => a + b, 0) / data.values.length).toFixed(3) : '0.000';
                    
                    item.innerHTML = `
                        <div class="joint-header">
                            <span class="joint-name">${jointName} (${mapping?.servo || 'N/A'})</span>
                        </div>
                        <div class="joint-slider-container">
                            <input type="range" 
                                   class="joint-slider ${jointType}" 
                                   data-joint="${jointName}"
                                   data-servo="${mapping?.servo || ''}"
                                   min="${limits.min}" 
                                   max="${limits.max}" 
                                   value="${limits.min}"
                                   step="1"
                                   disabled>
                            <div class="joint-controls">
                                <button class="test-joint" data-joint="${jointName}" data-servo="${mapping?.servo || ''}" disabled>Test</button>
                                <button class="reset-joint" data-joint="${jointName}" data-servo="${mapping?.servo || ''}" disabled>Reset</button>
                                <button class="calibrate-joint" data-joint="${jointName}" disabled>Calibrating...</button>
                            </div>
                        </div>
                    `;
                } else {
                    item.innerHTML = `
                        <div class="joint-header">
                            <span class="joint-name">${jointName} (${mapping?.servo || 'N/A'})</span>
                            <span class="joint-value">No data collected</span>
                        </div>
                        <div class="joint-slider-container">
                            <input type="range" 
                                   class="joint-slider ${jointType}" 
                                   data-joint="${jointName}"
                                   data-servo="${mapping?.servo || ''}"
                                   min="${limits.min}" 
                                   max="${limits.max}" 
                                   value="${limits.min}"
                                   step="1"
                                   disabled>
                            <div class="joint-controls">
                                <button class="test-joint" data-joint="${jointName}" data-servo="${mapping?.servo || ''}" disabled>Test</button>
                                <button class="reset-joint" data-joint="${jointName}" data-servo="${mapping?.servo || ''}" disabled>Reset</button>
                                <button class="calibrate-joint" data-joint="${jointName}" disabled>Calibrating...</button>
                            </div>
                        </div>
                    `;
                }
                jointMappingPreview.appendChild(item);
            }
        }

        // Update joint mapping preview from calibration data with interactive sliders
        function updateJointMappingPreviewFromCalibration() {
            jointMappingPreview.innerHTML = '';
            
            for (const [jointName, mapping] of Object.entries(handToServoMapping)) {
                const item = document.createElement('div');
                item.className = 'joint-mapping-item';
                
                // Determine joint type for color coding
                const jointType = getJointType(jointName);
                const limits = servoLimits[mapping.servo] || { min: 0, max: 100 };
                
                if (handCalibration.isCalibrated && handCalibration.minValues[jointName] !== undefined) {
                    const min = handCalibration.minValues[jointName];
                    const max = handCalibration.maxValues[jointName];
                    
                    item.innerHTML = `
                        <div class="joint-header">
                            <span class="joint-name">${jointName} (${mapping.servo})</span>
                        </div>
                        <div class="joint-slider-container">
                            <input type="range" 
                                   class="joint-slider ${jointType}" 
                                   data-joint="${jointName}"
                                   data-servo="${mapping.servo}"
                                   min="${limits.min}" 
                                   max="${limits.max}" 
                                   value="${limits.min}"
                                   step="1">
                            <div class="joint-controls">
                                <button class="test-joint" data-joint="${jointName}" data-servo="${mapping.servo}">Test</button>
                                <button class="reset-joint" data-joint="${jointName}" data-servo="${mapping.servo}">Reset</button>
                                <button class="calibrate-joint" data-joint="${jointName}">Calibrate</button>
                            </div>
                        </div>
                    `;
                } else {
                    item.innerHTML = `
                        <div class="joint-header">
                            <span class="joint-name">${jointName} (${mapping.servo})</span>
                            <span class="joint-value">Not calibrated</span>
                        </div>
                        <div class="joint-slider-container">
                            <input type="range" 
                                   class="joint-slider ${jointType}" 
                                   data-joint="${jointName}"
                                   data-servo="${mapping.servo}"
                                   min="${limits.min}" 
                                   max="${limits.max}" 
                                   value="${limits.min}"
                                   step="1">
                            <div class="joint-controls">
                                <button class="test-joint" data-joint="${jointName}" data-servo="${mapping.servo}">Test</button>
                                <button class="reset-joint" data-joint="${jointName}" data-servo="${mapping.servo}">Reset</button>
                                <button class="calibrate-joint" data-joint="${jointName}">Calibrate</button>
                            </div>
                        </div>
                    `;
                }
                jointMappingPreview.appendChild(item);
            }
            
            // Add event listeners for interactive controls
            addJointMappingEventListeners();
        }

        // Get joint type for color coding
        function getJointType(jointName) {
            if (jointName.includes('pinky')) return 'pinky';
            if (jointName.includes('ring')) return 'ring';
            if (jointName.includes('middle')) return 'middle';
            if (jointName.includes('index')) return 'index';
            if (jointName.includes('thumb')) return 'thumb';
            return 'default';
        }

        // Add event listeners for joint mapping controls
        function addJointMappingEventListeners() {
            // Slider event listeners
            const sliders = jointMappingPreview.querySelectorAll('.joint-slider');
            sliders.forEach(slider => {
                slider.addEventListener('input', (e) => {
                    const jointName = e.target.dataset.joint;
                    const servoId = e.target.dataset.servo;
                    const value = parseInt(e.target.value);
                    
                    // Update URDF model
                    updateURDFFromServo(servoId, value);
                    
                    // Send to physical servos if connected
                    if (isConnected) {
                        sendHandTrackingUpdate({ [servoId]: value });
                    }
                });
            });

            // Test button event listeners
            const testButtons = jointMappingPreview.querySelectorAll('.test-joint');
            testButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    const jointName = e.target.dataset.joint;
                    const servoId = e.target.dataset.servo;
                    const slider = jointMappingPreview.querySelector(`[data-joint="${jointName}"]`);
                    
                    if (slider) {
                        // Cycle through min, max, min positions
                        const limits = servoLimits[servoId] || { min: 0, max: 100 };
                        const currentValue = parseInt(slider.value);
                        const newValue = currentValue === limits.min ? limits.max : limits.min;
                        
                        slider.value = newValue;
                        updateURDFFromServo(servoId, newValue);
                        
                        if (isConnected) {
                            sendHandTrackingUpdate({ [servoId]: newValue });
                        }
                    }
                });
            });

            // Reset button event listeners
            const resetButtons = jointMappingPreview.querySelectorAll('.reset-joint');
            resetButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    const jointName = e.target.dataset.joint;
                    const servoId = e.target.dataset.servo;
                    const slider = jointMappingPreview.querySelector(`[data-joint="${jointName}"]`);
                    
                    if (slider) {
                        const limits = servoLimits[servoId] || { min: 0, max: 100 };
                        slider.value = limits.min;
                        updateURDFFromServo(servoId, limits.min);
                        
                        if (isConnected) {
                            sendHandTrackingUpdate({ [servoId]: limits.min });
                        }
                    }
                });
            });

            // Calibrate button event listeners
            const calibrateButtons = jointMappingPreview.querySelectorAll('.calibrate-joint');
            calibrateButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    const jointName = e.target.dataset.joint;
                    startIndividualJointCalibration(jointName);
                });
            });
        }

        // Start individual joint calibration
        function startIndividualJointCalibration(jointName) {
            if (!isTrackingActive) {
                alert('Please start hand tracking first to calibrate individual joints.');
                return;
            }
            
            console.log(`Starting individual calibration for ${jointName}...`);
            
            // Highlight the calibration button
            const button = jointMappingPreview.querySelector(`[data-joint="${jointName}"]`).closest('.joint-mapping-item').querySelector('.calibrate-joint');
            button.classList.add('active');
            button.textContent = 'Calibrating...';
            
            // Collect data for 5 seconds
            const calibrationData = { min: Infinity, max: -Infinity, values: [] };
            const startTime = Date.now();
            const duration = 5000;
            
            const calibrationInterval = setInterval(() => {
                if (lastHandLandmarks && isTrackingActive) {
                    const mapping = handToServoMapping[jointName];
                    if (mapping) {
                        try {
                            let value = 0;
                            if (mapping.type === 'bend') {
                                const [p1, p2, p3] = mapping.landmarks;
                                if (lastHandLandmarks[p1] && lastHandLandmarks[p2] && lastHandLandmarks[p3]) {
                                    value = calculateBendAngle(lastHandLandmarks[p1], lastHandLandmarks[p2], lastHandLandmarks[p3]);
                                }
                            } else if (mapping.type === 'spread') {
                                const [p1, p2] = mapping.landmarks;
                                if (lastHandLandmarks[p1] && lastHandLandmarks[p2]) {
                                    value = calculateSpread(lastHandLandmarks[p1], lastHandLandmarks[p2]);
                                }
                            }
                            
                            if (value > 0) {
                                calibrationData.values.push(value);
                                calibrationData.min = Math.min(calibrationData.min, value);
                                calibrationData.max = Math.max(calibrationData.max, value);
                            }
                        } catch (error) {
                            console.error(`Error calibrating ${jointName}:`, error);
                        }
                    }
                }
                
                if (Date.now() - startTime >= duration) {
                    clearInterval(calibrationInterval);
                    completeIndividualJointCalibration(jointName, calibrationData, button);
                }
            }, 200); // Reduced frequency to prevent excessive updates
        }

        // Complete individual joint calibration
        function completeIndividualJointCalibration(jointName, calibrationData, button) {
            if (calibrationData.min !== Infinity && calibrationData.max !== -Infinity && calibrationData.values.length > 3) {
                handCalibration.minValues[jointName] = calibrationData.min;
                handCalibration.maxValues[jointName] = calibrationData.max;
                console.log(`${jointName} individual calibration: min=${calibrationData.min.toFixed(3)}, max=${calibrationData.max.toFixed(3)}, samples=${calibrationData.values.length}`);
                
                button.textContent = 'Calibrated';
                button.style.background = '#28a745';
            } else {
                button.textContent = 'Failed';
                button.style.background = '#dc3545';
                console.log(`${jointName} individual calibration failed: insufficient data`);
            }
            
            button.classList.remove('active');
            
            // Save calibration data
            saveCalibrationToJSON();
        }

        // Start hand calibration
        function startHandCalibration() {
            if (!isTrackingActive) {
                alert('Please start hand tracking first to calibrate.');
                return;
            }
            
            console.log('Starting hand calibration...');
            calibrationStatus.textContent = 'Calibrating... Move your hand through full range of motion';
            calibrationStatus.className = 'calibration-status calibrating';
            
            // Reset calibration data
            handCalibration.minValues = {};
            handCalibration.maxValues = {};
            handCalibration.isCalibrated = false;
            
            // Initialize calibration data collection
            const calibrationData = {};
            const calibrationDuration = 20000; // 20 seconds for better data collection
            const startTime = Date.now();
            
            // Initialize data structure for all joints
            for (const [jointName, mapping] of Object.entries(handToServoMapping)) {
                calibrationData[jointName] = { min: Infinity, max: -Infinity, values: [] };
            }
            
            // Create calibration interval to collect data
            const calibrationInterval = setInterval(() => {
                if (lastHandLandmarks && isTrackingActive) {
                    console.log('Collecting calibration data...');
                    
                    // Process landmarks and collect min/max values
                    for (const [jointName, mapping] of Object.entries(handToServoMapping)) {
                        try {
                            let value = 0;
                            if (mapping.type === 'bend') {
                                const [p1, p2, p3] = mapping.landmarks;
                                if (lastHandLandmarks[p1] && lastHandLandmarks[p2] && lastHandLandmarks[p3]) {
                                    const angle = calculateBendAngle(lastHandLandmarks[p1], lastHandLandmarks[p2], lastHandLandmarks[p3]);
                                    value = angle;
                                    console.log(`${jointName} bend angle: ${angle.toFixed(3)}`);
                                }
                            } else if (mapping.type === 'spread') {
                                const [p1, p2] = mapping.landmarks;
                                if (lastHandLandmarks[p1] && lastHandLandmarks[p2]) {
                                    const spread = calculateSpread(lastHandLandmarks[p1], lastHandLandmarks[p2]);
                                    value = spread;
                                    console.log(`${jointName} spread: ${spread.toFixed(3)}`);
                                }
                            }
                            
                            // Store value and update min/max
                            if (value > 0) {
                                calibrationData[jointName].values.push(value);
                                calibrationData[jointName].min = Math.min(calibrationData[jointName].min, value);
                                calibrationData[jointName].max = Math.max(calibrationData[jointName].max, value);
                            }
                        } catch (error) {
                            console.error(`Error collecting calibration data for ${jointName}:`, error);
                        }
                    }
                    
                    // Update joint mapping preview during calibration (throttled)
                    updateJointMappingPreviewDuringCalibration(calibrationData);
                }
                
                // Check if calibration time is up
                if (Date.now() - startTime >= calibrationDuration) {
                    clearInterval(calibrationInterval);
                    completeHandCalibration(calibrationData);
                }
            }, 500); // Collect data every 500ms to reduce flickering
            
            // Update status during calibration
            const statusInterval = setInterval(() => {
                const remaining = Math.floor((calibrationDuration - (Date.now() - startTime)) / 1000);
                if (remaining > 0) {
                    calibrationStatus.textContent = `Calibrating... ${remaining}s remaining - Move your hand naturally`;
                }
            }, 1000);
            
            // Clear status interval when calibration completes
            setTimeout(() => {
                clearInterval(statusInterval);
            }, calibrationDuration);
        }

        function completeHandCalibration(calibrationData) {
            console.log('Completing hand calibration with data:', calibrationData);
            
            // Process collected calibration data
            for (const [jointName, data] of Object.entries(calibrationData)) {
                if (data.min !== Infinity && data.max !== -Infinity && data.values.length > 5) {
                    // Use collected data if we have enough samples
                    handCalibration.minValues[jointName] = data.min;
                    handCalibration.maxValues[jointName] = data.max;
                    console.log(`${jointName}: min=${data.min.toFixed(3)}, max=${data.max.toFixed(3)}, samples=${data.values.length}`);
                } else {
                    // Use improved default values if insufficient data
                    if (handToServoMapping[jointName].type === 'bend') {
                        if (jointName.includes('thumb')) {
                            handCalibration.minValues[jointName] = 0.1;
                            handCalibration.maxValues[jointName] = 0.9;
                        } else {
                            handCalibration.minValues[jointName] = 0.2;
                            handCalibration.maxValues[jointName] = 0.8;
                        }
                    } else {
                        if (jointName.includes('thumb')) {
                            handCalibration.minValues[jointName] = 0.05;
                            handCalibration.maxValues[jointName] = 0.5;
                        } else {
                            handCalibration.minValues[jointName] = 0.1;
                            handCalibration.maxValues[jointName] = 0.4;
                        }
                    }
                    console.log(`${jointName}: using default values (insufficient data: ${data.values.length} samples)`);
                }
            }
            
            handCalibration.isCalibrated = true;
            calibrationStatus.textContent = 'Calibration complete - Hand range captured successfully';
            calibrationStatus.className = 'calibration-status calibrated';
            updateCalibrationStatus();
            
            // Save calibration data to JSON
            saveCalibrationToJSON();
            
            // Update final joint mapping preview
            updateJointMappingPreviewFromCalibration();
            
            console.log('Hand calibration completed successfully');
        }

        // Reset hand calibration
        function resetHandCalibration() {
            console.log('Resetting hand calibration...');
            handCalibration = {
                minValues: {},
                maxValues: {},
                isCalibrated: false
            };
            localStorage.removeItem('handCalibration');
            saveCalibrationToJSON();
            updateCalibrationStatus();
            updateJointMappingPreviewFromCalibration();
        }

        // Save calibration to JSON file
        async function saveCalibrationToJSON() {
            try {
                const response = await fetchWithTimeout('http://localhost:8000/save_calibration', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ calibration: handCalibration })
                }, 5000);
                
                if (response.ok) {
                    console.log('Calibration saved to JSON');
                } else {
                    console.error('Failed to save calibration to JSON');
                }
            } catch (err) {
                console.error('Error saving calibration to JSON:', err);
            }
        }

        // Load calibration from JSON
        async function loadCalibrationFromJSON() {
            try {
                const response = await fetchWithTimeout('http://localhost:8000/load_calibration', {}, 5000);
                if (response.ok) {
                    const data = await response.json();
                    if (data.calibration) {
                        handCalibration = data.calibration;
                        updateCalibrationStatus();
                        updateJointMappingPreviewFromCalibration();
                        console.log('Calibration loaded from JSON');
                    }
                }
            } catch (err) {
                console.error('Error loading calibration from JSON:', err);
            }
        }

        // Auto-calibrate on first use with improved defaults
        function autoCalibrate() {
            if (!handCalibration.isCalibrated && isTrackingActive) {
                console.log('Auto-calibrating hand tracking...');
                calibrationStatus.textContent = 'Auto-calibrating... Move your hand naturally';
                calibrationStatus.className = 'calibration-status calibrating';
                
                // Set improved default calibration values based on typical hand ranges
                handCalibration.minValues = {
                    'pinky_pip': 0.2, 'ring_pip': 0.2, 'middle_pip': 0.2, 'index_pip': 0.2,
                    'pinky_mcp': 0.05, 'ring_mcp': 0.05, 'middle_mcp': 0.05, 'index_mcp': 0.05,
                    'thumb_mcp': 0.15, 'thumb_pip': 0.15, 'thumb_abduction': 0.05
                };
                handCalibration.maxValues = {
                    'pinky_pip': 0.9, 'ring_pip': 0.9, 'middle_pip': 0.9, 'index_pip': 0.9,
                    'pinky_mcp': 0.5, 'ring_mcp': 0.5, 'middle_mcp': 0.5, 'index_mcp': 0.5,
                    'thumb_mcp': 0.8, 'thumb_pip': 0.8, 'thumb_abduction': 0.4
                };
                handCalibration.isCalibrated = true;
                
                updateCalibrationStatus();
                saveCalibrationToJSON();
                
                setTimeout(() => {
                    calibrationStatus.textContent = 'Auto-calibration complete - Ready for tracking';
                    calibrationStatus.className = 'calibration-status calibrated';
                }, 2000);
            }
        }

        // Update calibration status
        function updateCalibrationStatus() {
            if (handCalibration.isCalibrated) {
                calibrationStatus.textContent = 'Calibrated';
                calibrationStatus.className = 'calibration-status calibrated';
            } else {
                calibrationStatus.textContent = 'Not calibrated';
                calibrationStatus.className = 'calibration-status not-calibrated';
            }
        }

        // Load hand calibration from localStorage
        function loadHandCalibration() {
            try {
                const saved = localStorage.getItem('handCalibration');
                if (saved) {
                    handCalibration = JSON.parse(saved);
                    updateCalibrationStatus();
                }
            } catch (error) {
                console.error('Error loading hand calibration:', error);
            }
        }

        // Initialize hand calibration on page load
        loadHandCalibration();
        
        // Function to continuously draw video to canvas (fallback for when MediaPipe is not processing)
        function startVideoDrawing() {
            const canvas = document.getElementById('camera-canvas');
            const ctx = canvas.getContext('2d');
            
            function drawVideo() {
                if (camera && camera.video && isTrackingActive) {
                    try {
                        // Clear canvas
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        // Draw video frame
                        ctx.drawImage(camera.video, 0, 0, canvas.width, canvas.height);
                    } catch (error) {
                        console.log('Video drawing error:', error);
                    }
                }
                requestAnimationFrame(drawVideo);
            }
            
            drawVideo();
        }
        
        // Safety function to ensure URDF model integrity
        function ensureURDFIntegrity() {
            if (urdfLoader && urdfLoader.robot) {
                try {
                    // Check if all joints are properly loaded
                    const jointNames = Object.values(jointMapping);
                    for (const jointName of jointNames) {
                        if (!urdfLoader.joints.has(jointName)) {
                            console.warn(`Joint ${jointName} not found in URDF model`);
                        }
                    }
                    
                    // Force a render update
                    if (urdfLoader.render) {
                        urdfLoader.render();
                    }
                } catch (error) {
                    console.error('Error checking URDF integrity:', error);
                }
            }
        }
        
        // Test MediaPipe processing manually
        function testMediaPipeProcessing() {
            console.log('Testing MediaPipe processing...');
            
            if (!hands) {
                console.error('MediaPipe Hands not initialized');
                alert('MediaPipe Hands not initialized. Please try starting hand tracking first.');
                return;
            }
            
            if (!camera || !camera.video) {
                console.error('Camera not available');
                alert('Camera not available. Please start hand tracking first.');
                return;
            }
            
            console.log('MediaPipe components available:', {
                hands: !!hands,
                camera: !!camera,
                video: !!(camera && camera.video),
                isTrackingActive: isTrackingActive
            });
            
            // Test sending a frame to MediaPipe
            try {
                hands.send({ image: camera.video }).then(() => {
                    console.log('Manual MediaPipe processing successful');
                }).catch((error) => {
                    console.error('Manual MediaPipe processing failed:', error);
                });
            } catch (error) {
                console.error('Error in manual MediaPipe test:', error);
            }
        }
        
        function drawHandConnections(ctx, landmarks) {
            // Hand connections with subtle styling for better UX
            const connections = [
                // Thumb connections - more subtle
                { points: [0, 1], color: 'rgba(255, 107, 107, 0.4)', width: 1 },
                { points: [1, 2], color: 'rgba(255, 107, 107, 0.4)', width: 1 },
                { points: [2, 3], color: 'rgba(255, 107, 107, 0.4)', width: 1 },
                { points: [3, 4], color: 'rgba(255, 107, 107, 0.4)', width: 1 },
                
                // Index finger connections
                { points: [0, 5], color: 'rgba(78, 205, 196, 0.4)', width: 1 },
                { points: [5, 6], color: 'rgba(78, 205, 196, 0.4)', width: 1 },
                { points: [6, 7], color: 'rgba(78, 205, 196, 0.4)', width: 1 },
                { points: [7, 8], color: 'rgba(78, 205, 196, 0.4)', width: 1 },
                
                // Middle finger connections
                { points: [0, 9], color: 'rgba(69, 183, 209, 0.4)', width: 1 },
                { points: [9, 10], color: 'rgba(69, 183, 209, 0.4)', width: 1 },
                { points: [10, 11], color: 'rgba(69, 183, 209, 0.4)', width: 1 },
                { points: [11, 12], color: 'rgba(69, 183, 209, 0.4)', width: 1 },
                
                // Ring finger connections
                { points: [0, 13], color: 'rgba(150, 206, 180, 0.4)', width: 1 },
                { points: [13, 14], color: 'rgba(150, 206, 180, 0.4)', width: 1 },
                { points: [14, 15], color: 'rgba(150, 206, 180, 0.4)', width: 1 },
                { points: [15, 16], color: 'rgba(150, 206, 180, 0.4)', width: 1 },
                
                // Pinky finger connections
                { points: [0, 17], color: 'rgba(255, 234, 167, 0.4)', width: 1 },
                { points: [17, 18], color: 'rgba(255, 234, 167, 0.4)', width: 1 },
                { points: [18, 19], color: 'rgba(255, 234, 167, 0.4)', width: 1 },
                { points: [19, 20], color: 'rgba(255, 234, 167, 0.4)', width: 1 },
                
                // Palm connections - very subtle
                { points: [5, 9], color: 'rgba(221, 160, 221, 0.2)', width: 0.5 },
                { points: [9, 13], color: 'rgba(221, 160, 221, 0.2)', width: 0.5 },
                { points: [13, 17], color: 'rgba(221, 160, 221, 0.2)', width: 0.5 }
            ];
            
            for (const connection of connections) {
                const [start, end] = connection.points;
                if (landmarks[start] && landmarks[end]) {
                    ctx.strokeStyle = connection.color;
                    ctx.lineWidth = connection.width;
                    ctx.lineCap = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(landmarks[start].x * ctx.canvas.width, landmarks[start].y * ctx.canvas.height);
                    ctx.lineTo(landmarks[end].x * ctx.canvas.width, landmarks[end].y * ctx.canvas.height);
                    ctx.stroke();
                }
            }
        }
        
        // Manual hand landmarks drawing with subtle styling for better UX
        function drawHandLandmarks(ctx, landmarks) {
            // Draw different colors for different parts of the hand with transparency
            const colors = {
                thumb: 'rgba(255, 107, 107, 0.6)',      // Coral red for thumb
                index: 'rgba(78, 205, 196, 0.6)',       // Turquoise for index
                middle: 'rgba(69, 183, 209, 0.6)',      // Sky blue for middle
                ring: 'rgba(150, 206, 180, 0.6)',       // Mint green for ring
                pinky: 'rgba(255, 234, 167, 0.6)',      // Light yellow for pinky
                palm: 'rgba(221, 160, 221, 0.4)'        // Plum for palm
            };
            
            // Define landmark groups
            const landmarkGroups = {
                thumb: [0, 1, 2, 3, 4],
                index: [5, 6, 7, 8],
                middle: [9, 10, 11, 12],
                ring: [13, 14, 15, 16],
                pinky: [17, 18, 19, 20],
                palm: [0]
            };
            
            // Draw landmarks with subtle styling
            for (const [group, indices] of Object.entries(landmarkGroups)) {
                ctx.fillStyle = colors[group];
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 0.5;
                
                for (const index of indices) {
                    if (landmarks[index]) {
                        const x = landmarks[index].x * ctx.canvas.width;
                        const y = landmarks[index].y * ctx.canvas.height;
                        
                        // Draw smaller, more subtle dots
                        const size = (group === 'palm' || index % 4 === 0) ? 3 : 2;
                        
                        // Create subtle gradient for better visual appeal
                        const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                        gradient.addColorStop(0, colors[group]);
                        gradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Add subtle border
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                        
                        // Reset fill style
                        ctx.fillStyle = colors[group];
                        
                        // Draw hand outline for better visual feedback
                        if (index === 0) { // Only draw outline once
                            drawHandOutline(ctx, landmarks);
                        }
                    }
                }
            }
        }

        // Simplified Kalman Filter for smoothing hand landmarks
        class KalmanFilter {
            constructor(processNoise = 0.01, measurementNoise = 0.1) {
                // Simple 3D position tracking with velocity
                this.position = [0, 0, 0];
                this.velocity = [0, 0, 0];
                this.processNoise = processNoise;
                this.measurementNoise = measurementNoise;
                this.isInitialized = false;
            }
            
            predict() {
                // Simple prediction step
                if (!this.isInitialized) return;
                
                // Update position based on velocity
                for (let i = 0; i < 3; i++) {
                    this.position[i] += this.velocity[i];
                }
                
                // Add process noise to velocity
                for (let i = 0; i < 3; i++) {
                    this.velocity[i] += (Math.random() - 0.5) * this.processNoise;
                }
            }
            
            update(measurement) {
                try {
                    // Validate measurement input
                    if (!measurement || !Array.isArray(measurement) || measurement.length !== 3) {
                        console.warn('Invalid measurement for Kalman filter update');
                        return [0, 0, 0];
                    }
                    
                    if (!this.isInitialized) {
                        // Initialize with first measurement
                        this.position = [...measurement];
                        this.isInitialized = true;
                        return this.position;
                    }
                    
                    // Simple Kalman update with exponential smoothing
                    const alpha = this.measurementNoise / (this.measurementNoise + this.processNoise);
                    
                    for (let i = 0; i < 3; i++) {
                        // Update position with weighted average
                        this.position[i] = (1 - alpha) * this.position[i] + alpha * measurement[i];
                        
                        // Update velocity based on position change
                        this.velocity[i] = (measurement[i] - this.position[i]) * 0.1;
                    }
                    
                    return this.position;
                } catch (error) {
                    console.error('Error in Kalman filter update:', error);
                    return this.position;
                }
            }
            
            // Simple vector operations for the simplified filter
            addVectors(a, b) {
                if (!a || !b || !Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) {
                    return a || [0, 0, 0];
                }
                return a.map((val, i) => val + b[i]);
            }
            
            subtractVectors(a, b) {
                if (!a || !b || !Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) {
                    return a || [0, 0, 0];
                }
                return a.map((val, i) => val - b[i]);
            }
        }

        // Initialize Kalman filters for each landmark
        let kalmanFilters = [];
        for (let i = 0; i < 21; i++) {
            kalmanFilters.push(new KalmanFilter(0.01, 0.1));
        }
        
        // Reset Kalman filters when tracking starts
        function resetKalmanFilters() {
            kalmanFilters = [];
            for (let i = 0; i < 21; i++) {
                kalmanFilters.push(new KalmanFilter(0.01, 0.1));
            }
            console.log('Kalman filters reset');
        }
        
        // Adjust Kalman filter parameters based on tracking performance
        function adjustKalmanParameters(processNoise = 0.01, measurementNoise = 0.1) {
            kalmanFilters = [];
            for (let i = 0; i < 21; i++) {
                kalmanFilters.push(new KalmanFilter(processNoise, measurementNoise));
            }
            console.log(`Kalman filters adjusted - Process noise: ${processNoise}, Measurement noise: ${measurementNoise}`);
        }
    </script>
    <script src="urdf-loader.js"></script>
</body>
</html>